# automata-as-tools
Experiments with making tools based on different classes of automata/abstract machines.

*Actually, the tool-making part is less relevant at the moment, but I think it will resurface.*

Mostly done, I think:

* Finite state machine
* Finite state transducer
* Push-down automaton

Doing

* Post-Turing machine
* (Basic) Turing machine

Prospective

* Karel robot
* Register machine

## Classes overview

### Component

This class is used for most of the values that make up the machine-defining tuples. The value itself can be a scalar or a set (set is default).

**Behavior:**

* `get` : yields the underlying value
* `set ?value...?` : sets the underlying value by replacing a scalar or inserting new values in a set. 
* `forall var cond coll` : tests condition *cond* once for every member of collection *coll*. The value of *var* is set to the value of the item when *cond* is evaluated. Returns 1 if every item passes the test, and aborts testing with a return value of 0 if any test fails.
* `any var cond coll` : tests condition *cond* once for every member of collection *coll*. The value of *var* is set to the value of the item when *cond* is evaluated. Returns 0 if no item passes the test, and aborts testing with a return value of 1 if any test passes.

**Creation:**

The following options are recognized by the constructor:

* `-scalar` : sets the value type to *scalar*.
* `-nonempty` : the set or scalar will not accept empty values
* `-in cmd` : registers a command prefix. When the component's value is set, this command prefix will be called as `cmd set val` for every value passed as argument to the component's `set` method.

If any further arguments are given, the first of those will be set as a scalar component's value, or all of them as a set component's value.

**TODO:** this class is largely untested except as part of using other classes.

### STE (State Transition Engine)

### TME (Turing Machine Engine)

### FSM (Finite State Machine)

A Finite State Machine recognizes a regular language. It can be
asked to accept or classify a list of input symbols.

This machine is defined by the tuple `\<A, Q, S, F, T\>`:

* *A* is the input alphabet (does not accept the empty string as symbol).
* *Q* is the set of state symbols.
* *S* is a symbol which is a member of the set of state symbols (for a deterministic FSM) or a set of symbols which is a subset of the state symbols (for a nondeterministic FSM). Processing will start at this/these symbols.
* *F* is a set of symbols which is a subset of *Q*. These are the accepting final states.
* *T* is the transition relation, an instance of the `STE` class.

**Behavior:**

* `A`, `Q`, `S`, `F`, `T` : public methods to give access to the components.
* `accept symbols` : steps through the transition space using the list of symbols passed into it as input symbols. Returns 1 if an accepting final state is reached when the input is exhausted. In a nondeterministic machine, returns 1 if one of the resulting states is acceptable. Otherwise, returns 0.
* `classify symbols` : As `accept`, but returns a (possibly empty) list of the final states when the input is exhausted.

### FST (Finite State Transducer)

A Finite State Transducer recognizes or encodes a regular relation.
It can be asked to *recognize* two lists of symbols, i.e. indicate if they fulfill the relation; or *translate* a list of input symbols into a list of output symbols that fulfills the relation; or *reconstruct* a list of input symbols from a list of output symbols, or *generate* a list of input symbols and a list of output symbols by walking a given number of steps through the transition space.

This machine is defined by the tuple `\<A, B, Q, S, F, T\>`:

* *A* is the input alphabet (does not accept the empty string as symbol).
* *B* is the output alphabet (does not accept the empty string as symbol).
* *Q* is the set of state symbols.
* *S* is a symbol which is a member of the set of state symbols (for a deterministic FST) or a set of symbols which is a subset of the state symbols (for a nondeterministic FST). Processing will start at this/these symbols.
* *F* is a set of symbols which is a subset of *Q*. These are the accepting final states.
* *T* is the transition relation, an instance of the `STE` class.

**Behavior:**

* `A`, `B`, `Q`, `S`, `F`, `T` : public methods to give access to the components.
* `recognize input output` : Returns 1 if the symbol lists fulfill the relation. Otherwise, returns 0.
* `translate input` : Returns a list of output symbols for the given input symbols.
* `reconstruct output` : Returns a list of input symbols for the given output symbols.
* `generate steps` : Returns a list of input symbols and a list of output symbols generated by *steps* transition steps.

### PDA (Pushdown Automaton)

This machine is defined by the tuple `\<A, B, Q, Z, S, F, T\>`:

* *A* is the input alphabet (does not accept the empty string as symbol).
* *B* is the stack alphabet (does not accept the empty string as symbol).
* *Q* is the set of state symbols.
* *Z* is a symbol which is a member of the set of stack symbols. The stack will contain this symbol when starting.
* *S* is a symbol which is a member of the set of state symbols. Processing will start at this symbol.
* *F* is a set of symbols which is a subset of *Q*. These are the accepting final states.
* *T* is the transition relation, an instance of the `STE` class.

**Behavior:**

* `A`, `B`, `Q`, `Z`, `S`, `F`, `T` : public methods to give access to the components.
* `accept symbols` : steps through the transition space using the list of symbols passed into it as input symbols, and also the stack. Returns 1 if an accepting final state is reached when the input is exhausted. Otherwise, returns 0.
* `classify symbols` : As `accept`, but returns a (possibly empty) list of the final states when the input is exhausted.

