package require tcltest
namespace import ::tcltest::*

::tcltest::configure {*}$argv

::tcltest::testConstraint skip 0
::tcltest::testConstraint noskip 1

::tcltest::loadTestedCommands

cleanupTests ; return

package require pda
package require string::token

dict set δ (q0,ε,S) {qe {}}
dict set δ (q0,0,S) {q0 Z}
dict set δ (q0,0,Z) {q0 {Z Z}}
dict set δ (q0,1,Z) {q1 {}}
dict set δ (q1,1,Z) {q1 {}}
dict set δ (q1,ε,S) {qf {}}

test pda-1.0 {} -setup {
    set res {}
    ::pda::PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
} -body {
    lindex [M read {}] 0
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1


test pda-1.1 {} -setup {
    set res {}
    ::pda::PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
} -body {
    lindex [M read {0 0 0 0 1 1 1 1}] 0
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1


test pda-1.2 {} -setup {
    set res {}
    ::pda::PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
} -body {
    lindex [M read {0 0 0 0 1 1 1 1 1}] 0
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 0


test pda-1.3 {} -setup {
    set res {}
    ::pda::PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
} -body {
    M read {0 1 1}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 {(q0,0,S) -> q0 {Z S}} {(q0,1,Z) -> q1 S} {(q1,1,S) -> FAIL}}


test pda-1.4 {} -setup {
    set res {}
    ::pda::PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ ${δ} s q0 Z S F {qe qf}]
} -body {
    M read {0 1 1}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 {(q0,0,S) -> q0 {Z S}} {(q0,1,Z) -> q1 S} {(q1,1,S) -> FAIL}}


test pda-1.5 {} -setup {
    set res {}
} -body {
    ::pda::PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S} s q666 Z S]
    M read {0}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {illegal state value "q666" not in "q0, q1, qe, qf"} -returnCodes error


test pda-1.6 {} -setup {
    set res {}
    ::pda::PDA create M [dict create Q {q0 q1 qe qf} Σ {0 1} Γ {S Z} δ {} s q0 Z S F {qe qf}]
    oo::objdefine M mixin ::pda::PDAWithSlave
    M addTransition q0      ε S {qe {}    {emit success "no input"}}
    M addTransition q0      0 S {q0 Z     {emit LVL [incr n]}}
    M addTransition q0      0 Z {q0 {Z Z} {emit LVL [incr n]}}
    M addTransition {q[01]} 1 Z {q1 {}    {emit LVL [incr n -1]}}
    M addTransition q1      ε S {qf {}    {emit success match}}
} -body {
    set slave [::pda::Slave new {emit -clear}]
    $slave source pdaslave.tcl
    M read {} $slave
    lappend res [$slave eval emit]
    M read {0 1 1} $slave
    lappend res [$slave eval emit]
    M read {0 0 1 1} $slave
    lappend res [$slave eval emit]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{success {no input}} {LVL 1 LVL 0} {LVL 1 LVL 2 LVL 1 LVL 0 success match}}


test pda-2.0 {} -setup {
    set res {}
    ::pda::PDA create M {
        Q {q0 q1 q2 q3 q4 qe qf}
        Σ {sp w nl}
        Γ {S}
        s q0
        Z S
        F {qe qf}
    }
    oo::objdefine M mixin ::pda::PDAWithSlave
    M addTransition {q[0-4]} nl S {q0 {}    {}}
    M addTransition q0       ε  S {qe {}    {emit success "no input"}}
    M addTransition q0       sp S {q0 {}    {}}
    M addTransition {q[01]}  w  S {q1 {}    {emit cmd $2}}
    M addTransition {q[12]}  sp S {q2 {}    {}}
    M addTransition {q[234]} w  S {q3 {}    {emit arg $2}}
    M addTransition {q[34]}  sp S {q4 {}    {}}
    M addTransition {q[1-4]} ε  S {qf {}    {emit success match}}
} -body {
    M read {} $slave
    lappend res [$slave eval emit]
    M read {sp sp {w foo} sp} $slave
    lappend res [$slave eval emit]
    M read {sp {w foo} sp sp {w bar} sp} $slave
    lappend res [$slave eval emit]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{success {no input}} {cmd foo success match} {cmd foo arg bar success match}}


test pda-2.1 {} -setup {
    set res {}
    ::pda::PDA create M {
        Q {q0 q1 q2 q3 q4 qe qf}
        Σ {sp w n}
        Γ {S}
        s q0
        Z S
        F {qe qf}
    }
} -body {
    M addTransition {q[0-4]} nl S {q0 {}    {}}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {no matching keys for "nl"} -returnCodes error


test pda-2.2 {} -constraints {} -setup {
    set res {}
    ::pda::PDA create M {
        Q {qe qf q0 q1 q2 q3 q4}
        Σ {sp w nl lb rb dq lc rc em}
        Γ {S B Q C}
        s q0
        Z S
        F {qe qf}
    }
    oo::objdefine M mixin ::pda::PDAWithSlave
    # qe    script empty
    # qf    script finished
    # q0    start state, before script
    #
    # q1    before command
    # q2    in word, more text may follow
    # q3    in word, no more text
    # q4    interword space or after command
    # 20180515 expands from 25 calls to 103 rules
    M addTransition q0       ε  S {qe {}    {emit success "no input"}}
    M addTransition {q[1-4]} ε  S {qf {}    {emit success done}}

    M addTransition q0       w  S {q2 -     {emit add $2}}
    M addTransition {q[12]}  w  * {q2 -     {emit add $2}}
    M addTransition q4       w  * {q2 -     {emit space add $2}}

    M addTransition q4       em * {q3 -     {emit space add $2}}

    M addTransition q0       nl S {q1 {}}
    M addTransition {q[1-4]} nl * {q1 -     {emit command}}

    M addTransition q1       sp * {q1 -}
    M addTransition {q[01]}  sp S {q1 {}}
    M addTransition {q[2-4]} sp * {q4 -}

    M addTransition {q[0-2]} lb S {q1 {B}   {emit enter B}}
    M addTransition {q[0-2]} dq S {q1 {Q}   {emit enter Q}}
    M addTransition {q[0-2]} lc S {q1 {C}   {emit enter C}}
    
    M addTransition {q[4]}   lb S {q1 {B}   {emit space enter B}}
    M addTransition {q[4]}   dq S {q1 {Q}   {emit space enter Q}}
    M addTransition {q[4]}   lc S {q1 {C}   {emit space enter C}}
    
    M addTransition {q[12]}  lb B {q1 {B B} {emit enter B}}
    M addTransition {q[12]}  dq B {q1 {Q B} {emit enter Q}}
    M addTransition {q[12]}  lc B {q1 {C B} {emit enter C}}

    M addTransition {q[4]}   lb B {q1 {B B} {emit space enter B}}
    M addTransition {q[4]}   dq B {q1 {Q B} {emit space enter Q}}
    M addTransition {q[4]}   lc B {q1 {C B} {emit space enter C}}

    M addTransition {q[12]}  lb Q {q1 {B Q} {emit enter B}}
    M addTransition {q[12]}  lc Q {q1 {C Q} {emit enter C}}
    
    M addTransition {q[4]}   lb Q {q1 {B Q} {emit space enter B}}
    M addTransition {q[4]}   lc Q {q1 {C Q} {emit space enter C}}
    
    M addTransition {q[12]}  lb C {q1 {B C} {emit enter B}}
    M addTransition {q[12]}  dq C {q1 {Q C} {emit enter Q}}
    M addTransition {q[12]}  lc C {q1 {C C} {emit enter C}}

    M addTransition {q[4]}   lb C {q1 {B C} {emit space enter B}}
    M addTransition {q[4]}   dq C {q1 {Q C} {emit space enter Q}}
    M addTransition {q[4]}   lc C {q1 {C C} {emit space enter C}}

    M addTransition {q[1-4]} rb B {q2 {}    {emit leave}}
    
    M addTransition {q[124]} dq Q {q3 {}    {emit leave}}

    M addTransition {q[1-4]} rc C {q3 {}    {emit leave}}
    
} -body {
    set lex {
    {(\\.|[\w:$!%&'()*,-./?@+<=>^`|~])+}    w
    {[ \t]+}                                sp
    {\n}                                    nl
    {\;}                                    sc
    {\#}                                    ns
    {\"\"|\{\}|\[\]}                        em
    {\"}                                    dq
    {\{\*\}}                                ex
    {\{}                                    lc
    {\}}                                    rc
    {\[}                                    lb
    {\]}                                    rb
    .                                       Other
    }
    set slave [::pda::Slave new {
        emit init
        emit enter S
    }]
    $slave source pdaslave.tcl
    set code {set fp [open "D:\\RWTH\\Mini thesis\\EclipseTCL\\TCL trial\\excelv1.csv" r]
set secondColumnData {}
while {[gets $fp line]>=0} {
    if {[llength $line]>0} {
        lappend secondColumnData [lindex [split $line ","] 1]
    }
}
close $fp 
puts $secondColumnData}
    set tokens [::string::token text $lex $code]
    M read [lmap token $tokens {lassign $token sym beg end ; list $sym [string range $code $beg $end]}] $slave
    lappend res [$slave eval emit]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{init enter S add set space add fp space enter B add open space enter Q add {D:\\RWTH\\Mini} space add {thesis\\EclipseTCL\\TCL} space add {trial\\excelv1.csv} leave space add r leave command add set space add secondColumnData space add {{}} command add while space enter C enter B add gets space add {$fp} space add line leave add >=0 leave space enter C command add if space enter C enter B add llength space add {$line} leave add >0 leave space enter C command add lappend space add secondColumnData space enter B add lindex space enter B add split space add {$line} space enter Q add , leave leave space add 1 leave command leave command leave command add close space add {$fp} command add puts space add {$secondColumnData} success done}}


::tcltest::cleanupTests
