package require tcltest
namespace import ::tcltest::*

::tcltest::configure {*}$argv

::tcltest::testConstraint noskip 1

::tcltest::loadTestedCommands

package require automata::tablemachine

test pda-1.0 {0^n1^n | n >= 0} -setup {
    ::automata::Automaton create M {
        table Q A B B* T
        tuples {*}{
            {p 0/Z;AZ p}
            {p 0/A;AA p}
            {p _/Z;Z  q}
            {p _/A;A  q}
            {q 1/A;_  q}
            {q _/Z;Z  r}
        }
        start p
        final r
        stack Z
        frame input state stack
    }
} -body {
    M acceptPDA {}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1

test pda-1.1 {0^n1^n | n >= 0} -setup {
    ::automata::Automaton create M {
        table Q A B B* T
        tuples {*}{
            {p 0/Z;AZ p}
            {p 0/A;AA p}
            {p _/Z;Z  q}
            {p _/A;A  q}
            {q 1/A;_  q}
            {q _/Z;Z  r}
        }
        start p
        final r
        stack Z
        frame input state stack
    }
} -body {
    M acceptPDA {0 0 0 0 1 1 1 1}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1

if {[package vcompare [package present automata::tablemachine] 0.4] > 0} { 
    cleanupTests ; return 
} 
 

set mc PDA
set m [subst {::automata::$mc create M}]
{*}$m
M doc [file join ~ code automata-as-tools.wiki class.$mc.md]
M destroy

test pda-1.1 {} -setup {
    ::automata::PDA create M
    M compile {
        {<p 0/Z;A,Z p}
        { p 0/A;A,A p}
        { p ε/Z;Z   q}
        { p ε/A;A   q}
        { q 1/A;ε   q}
        { q ε/Z;Z   r>}
    }
} -body {
    M accept {0 0 0 0 1 1 1 1}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1

test pda-1.2 {} -setup {
    ::automata::PDA create M
    M compile {
        {<p 0/Z;A,Z p}
        { p 0/A;A,A p}
        { p ε/Z;Z   q}
        { p ε/A;A   q}
        { q 1/A;ε   q}
        { q ε/Z;Z   r>}
    }
} -body {
    set res {}
    lappend res [M accept {0 0 0 0 1 1 1 1 1}]
    lappend res [M accept {1 1 0}]
    lappend res [M accept {0 1}]
    lappend res [M accept {0 0 0 1 1 1}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 0 1 1}

test pda-1.3 {} -setup {
    ::automata::PDA create M
    M compile {
        {<p 0/Z;A,Z p}
        { p 0/A;A,A p}
        { p ε/Z;Z   q}
        { p ε/A;A   q}
        { q 1/A;ε   q}
        { q ε/Z;Z   r>}
    }
} -body {
    M print
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -output {Input symbols     A = {0, 1}
Stack symbols     B = {Z, A}
State symbols     Q = {p, q, r}
Start symbol      S = p
Initial stack     Z = Z
Final symbols     F = {r}
Transitions
q0    inp   q1    out
p     0     p     Z {A Z}
p     0     p     A {A A}
p     ε     q     Z Z
p     ε     q     A A
q     1     q     A {}
q     ε     r     Z Z
Instantaneous description
remaining input        input: A*
current state          state: Q
current stack          stack: B*
}

cleanupTests ; return

if {[package vcompare [package present automata::pda] 0.1] > 0} { 
    cleanupTests ; return 
} 
 

