package require tcltest
namespace import ::tcltest::*

::tcltest::configure {*}$argv

::tcltest::testConstraint noskip 1

::tcltest::loadTestedCommands

package require automata::ptm

test ptm-1.0 {2 state, 2 symbol busy beaver} -setup {} -body {
    ::automata::PTM create M
    M compile {
        A:	J1:+4
            P
            R
            J:B
            P
            L
            J:B
        B:	J1:+4
            P
            L
            J:A
            P
            N
            J:H
        H:	H
    }
    M run {0} 0
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{1 1 1 1} 16 1}}

test ptm-1.1 {2 state, 2 symbol busy beaver, print} -setup {} -body {
    ::automata::PTM create M
    M compile {
        A:	J1:+4
            P
            R
            J:B
            P
            L
            J:B
        B:	J1:+4
            P
            L
            J:A
            P
            N
            J:H
        H:	H
    }
    M print
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -output {Tape alphabet   A = {0, 1}
Blank symbol    b = 0
State symbols   Q = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}
Program start   S = 1
Program end     F = 16
Transitions
q0    inp   q1    out
1     0     2     N N
1     1     5     N N
2     0     3     1 N
2     1     3     1 N
3     0     4     N R
3     1     4     N R
4     0     8     N N
4     1     8     N N
5     0     6     1 N
5     1     6     1 N
6     0     7     N L
6     1     7     N L
7     0     8     N N
7     1     8     N N
8     0     9     N N
8     1     12    N N
9     0     10    1 N
9     1     10    1 N
10    0     11    N L
10    1     11    N L
11    0     1     N N
11    1     1     N N
12    0     13    1 N
12    1     13    1 N
13    0     14    N N
13    1     14    N N
14    0     15    N N
14    1     15    N N
15    0     16    N N
15    1     16    N N
}

test ptm-1.2 {multiply two numbers in unary} -setup {} -body {
    ::automata::PTM create M
    M compile {
                 R J1:-1 R J1:-1 R P
                 L
        a_loop:  L J1:-1 L J1:-1 R
                 E
                 R J0:done
                 R J1:-1 R
        b_loop:  R
                 J0:a_loop
                 E
                 R J1:-1 R J1:-1
                 P
                 L J1:-1 L J1:-1 P
                 J1:b_loop
                 R
                 J0:a_loop
                 E
        done:    H
    }
    M run {0 1 1 1 1 0 1 1 1 1 1 0 0} 0
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{0 0 0 0 0 0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0} 37 5}}

cleanupTests ; return ; # ---------------------------------
