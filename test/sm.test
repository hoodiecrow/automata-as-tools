package require tcltest
namespace import ::tcltest::*

::tcltest::configure {*}$argv

::tcltest::loadTestedCommands

package require automata::machine

test sm-1.0 {Calculate 4 x (2 + 3)} -body {
    ::automata::SM create M {
        code {
            2 3 ADD 4 MUL
        }
    }
    M run {}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {20 5}

if {[package vcompare [package present automata::machine] 0.4] > 0} { 
    cleanupTests ; return 
} 
 

set mc SM
set m [subst {::automata::$mc create M}]
{*}$m
M doc [file join ~ code automata-as-tools.wiki class.$mc.md]
M destroy

test sm-1.1 {print 1.0} -setup {
    ::automata::SM create M
} -body {
    M compile {
        2 3 ADD 4 MUL
    }
    M print
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -output {Flag symbols      A = {0, 1}
Addresses         Q = {0, 1, 2, 3, 4, 5}
Start address     S = 0
Final address     F = 5
Transitions
q0    inp   q1    out
0     0     1     0 N {PUSH 2}
0     1     1     0 N {PUSH 2}
1     0     2     0 N {PUSH 3}
1     1     2     0 N {PUSH 3}
2     0     3     0 N ADD
2     1     3     0 N ADD
3     0     4     0 N {PUSH 4}
3     1     4     0 N {PUSH 4}
4     0     5     0 N MUL
4     1     5     0 N MUL
Instantaneous description
stack contents         stack: V*
instruction pointer    ipointer: Q
}

test sm-2.0 {Implement a CLR operation} -setup {
    ::automata::SM create M
} -body {
    M compile {
            3
    a:      JZ:end,0
            DEC
            J:a
    end:    NOP
    }
    M run {}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 5}

test sm-2.1 {Print 2.0} -setup {
    ::automata::SM create M
} -body {
    M compile {
            3
    a:      JZ:end,0
            DEC
            J:a
    end:    NOP
    }
    M print
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -output {Flag symbols      A = {0, 1}
Addresses         Q = {0, 1, 2, 3, 4, 5}
Start address     S = 0
Final address     F = 5
Transitions
q0    inp   q1    out
0     0     1     0 N {PUSH 3}
0     1     1     0 N {PUSH 3}
1     0     2     0 N {JC 0 0}
1     1     4     0 N {JC 0 0}
2     0     3     0 N {D 0}
2     1     3     0 N {D 0}
3     0     1     0 N N
3     1     1     0 N N
4     0     5     0 N N
4     1     5     0 N N
Instantaneous description
stack contents         stack: V*
instruction pointer    ipointer: Q
}

cleanupTests ; return ; # ---------------------------------
