package require tcltest
namespace import ::tcltest::*

::tcltest::configure {*}$argv

::tcltest::testConstraint noskip 1

::tcltest::loadTestedCommands

package require automaton

proc foo d {
    dict for {state edges} $d {
        dict for {edge data} $edges {
            lassign [split $data :] a b
            dict lappend t $state $edge $a
            dict lappend o $state $edge $b
        }
    }
    list $t $o
}

# http://cs.union.edu/~striegnk/courses/nlp-with-prolog/html/node13.html

test dfst-1.0 {} -body {
    DFST create M {s 1 A 1} {1 "a a" 2 2 "ε a" 1}
    M generate 2
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{a a} {a a a a}}


test dfst-1.1 {} -body {
    DFST create M {s 1 A 1} {1 "a a" 2 2 "ε a" 1}
    M recognize {a a} {a a a a}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1


test dfst-1.2 {} -body {
    DFST create M {s 1 A 1} {1 "a a" 2 2 "ε a" 1}
    M translate {a a}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {a a a a}


test dfst-1.3 {} -body {
    DFST create M {s 1 A 1} {1 "a a" 2 2 "ε a" 1}
    M reconstruct {a a a a}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {a a}

test dfst-2.0 {The output becomes 1 and remains 1 thereafter when at least two 0's and two 1's have occurred as inputs} -body {
    DFST create M {
        I {0 1}
        O {0 1}
        S {A B C D E F G H I}
        s A
        A {A B C D E F G H I}
    } {
        A "0 0" D
        A "1 0" B
        B "0 0" E
        B "1 0" C
        C "0 0" F
        C "1 0" C
        D "0 0" G
        D "1 0" E
        E "0 0" H
        E "1 0" F
        F "0 0" I
        F "1 0" F
        G "0 0" G
        G "1 0" H
        H "0 0" H
        H "1 0" I
        I "0 1" I
        I "1 1" I
    }
    set res {}
    lappend res [M translate {1 1}]
    lappend res [M translate {1 1 0 0}]
    lappend res [M translate {1 1 0 0 1 0 1 1}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{0 0} {0 0 0 0} {0 0 0 0 1 1 1 1}}

test dfst-2.1 {edge detector} -body {
    DFST create M {
        I {0 1}
        O {0 1}
        S {si s0 s1}
        s si
        A {s0 s1}
    } {
        si "0 0" s0
        si "1 0" s1
        s0 "0 0" s0
        s0 "1 1" s1
        s1 "0 1" s0
        s1 "1 0" s1
    }
    set res {}
    lappend res [M translate {1 1 0}]
    lappend res [M translate {0 0 1}]
    lappend res [M translate {1 1 0 0 1 0 1 1}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{0 0 1} {0 0 1} {0 0 1 0 1 1 1 0}}

test dfst-2.2 {moore machine} -body {
    DFST create M {
        I {0 1}
        O {0 1}
        S {A B C D E F G H I}
        td {
            A {0 D 1 B}
            B {0 E 1 C}
            C {0 F 1 C}
            D {0 G 1 E}
            E {0 H 1 F}
            F {0 I 1 F}
            G {0 G 1 H}
            H {0 H 1 I}
            I {0 I 1 I}
        }
        od {
            A 0
            B 0
            C 0
            D 0
            E 0
            F 0
            G 0
            H 0
            I 1
        }
        s A
        A {A B C D E F G H I}
    } {} moore
    set res {}
    lappend res [M translate {1 1}]
    lappend res [M translate {1 1 0 0}]
    lappend res [M translate {1 1 0 0 1 0 1 1}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{0 0} {0 0 0 0} {0 0 0 0 1 1 1 1}}



# http://web.cs.ucdavis.edu/~rogaway/classes/120/spring13/eric-transducers.pdf


cleanupTests ; return ; # ---------------------------------




    set Tlaugh [list {
        0 1 2 3 4 5 6
    } [linsert [split laugh {}] end {}] {
        h a {}
    } {
        0 {l 1}
        1 {a 2}
        2 {u 3}
        3 {g 4}
        4 {h 5}
        5 {{} 6}
        6 {{} 5}
    } {
        0 {l h}
        1 {a a}
        2 {u {}}
        3 {g {}}
        4 {h {}}
        5 {{} h}
        6 {{} a}
    } 0 {5}]

    set Tlex [list {
        0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
    } {
        c d e f g h i m o s u ε
    } {
        NOUN pl sg ε
    } {
        0 {d 1 f 2 g 3 m 4}
        1 {o 14}
        2 {i 12}
        3 {o 10 e 11}
        4 {o 6 i 5}
        5 {c 8}
        6 {u 7}
        7 {s 8}
        8 {e 9}
        10 {o 7}
        11 {e 7}
        12 {s 13}
        13 {h 9}
        14 {g 9}
        15 {g 16}
        16 {s 9}
    } {
        0 {d NOUN f NOUN g NOUN m NOUN}
        1 {o sg}
        2 {i sg}
        3 {o sg e pl}
        4 {o sg i pl}
        5 {c {}}
        6 {u {}}
        7 {s {}}
        8 {e {}}
        10 {o {}}
        11 {e {}}
        12 {s {}}
        13 {h {}}
        14 {g {}}
        15 {g {}}
        16 {s {}}
    } 0 {9}]

test nfst-1.0 {} -body {
    NFST create M {*}$Tlex
    log::lvSuppressLE i 0
    M exec [split dog {}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {NOUN sg}

test nfst-1.1 {} -body {
    NFST create M {*}$Tlex
    log::lvSuppressLE i 0
    set res {}
    lappend res [M exec [split dogs {}]]
    lappend res [M exec [split goose {}]]
    lappend res [M exec [split geese {}]]
    lappend res [M exec [split mouse {}]]
    lappend res [M exec [split mice {}]]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {NOUN sg}




cleanupTests ; return ; # ---------------------------------




test dfa-1.0 {accept binary numbers that are multiples of 3} -body {
    FSM create M {
        I {0 1}
        S {s0 s1 s2}
        s s0
        t {
            {s0 0} s0
            {s0 1} s1
            {s1 0} s2
            {s1 1} s0
            {s2 0} s1
            {s2 1} s2
        }
        A s0
    }
    tuple2json [M tuple]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{
    "I" : ["0","1"],
    "S" : ["s0","s1","s2"],
    "s" : "s0",
    "t" : {
        "s0 0" : ["s0"],
        "s0 1" : ["s1"],
        "s1 0" : ["s2"],
        "s1 1" : ["s0"],
        "s2 0" : ["s1"],
        "s2 1" : ["s2"]
    },
    "A" : ["s0"]
}}

test dfa-1.1 {} -body {
    FSM create M {
        json {
            {
                "I": [0, 1],
                "S": ["s0", "s1", "s2"],
                "s": "s0",
                "t": {
                    "s0 0": "s0",
                    "s0 1": "s1",
                    "s1 0": "s2",
                    "s1 1": "s0",
                    "s2 0": "s1",
                    "s2 1": "s2"
                },
                "A": "s0"
            }
        }
    }
    set res {}
    lappend res [M run {1}]
    lappend res [M run {0 1}]
    lappend res [M run {1 1}]
    lappend res [M run {0 0 1}]
    lappend res [M run {1 0 1}]
    lappend res [M run {0 1 1}]
    lappend res [M run {1 1 1}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 0 1 0 0 1 0}

test nfa-1.0 {} -body {
    FSM create M {
        I {0 1}
        S {s0 s1 s2}
        s s0
        t {
            {s0 0} s0
            {s0 1} {s0 s1}
            {s1 0} s0
            {s1 1} s1
        }
        A s1
    }
    set res {}
    lappend res [M run {1}]
    lappend res [M run {0}]
    lappend res [M run {1 1}]
    lappend res [M run {1 0}]
    lappend res [M run {0 1}]
    lappend res [M run {0 0}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 1 0 1 0}

test nfa-1.1 {find even number of ones/zeros} -body {
    FSM create M {
        I {0 1}
        S {s0 s1 s2 s3 s4}
        s s0
        t {
            {s0 {}} {s1 s3}
            {s1 0} s2
            {s1 1} s1
            {s2 0} s1
            {s2 1} s2
            {s3 0} s3
            {s3 1} s4
            {s4 0} s4
            {s4 1} s3
        }
        A {s1 s3}
    }
    set res {}
    lappend res [M run {1 1}]
    lappend res [M run {1 0}]
    lappend res [M run {0 1}]
    lappend res [M run {0 0}]
    lappend res [M run {1 0 0 1 1 1}]
    lappend res [M run {1 0 0 1 1 0}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 0 1 1 0}

test fst-1.0 {The output becomes 1 and remains 1 thereafter when at least two 0's and two 1's have occurred as inputs} -body {
    FST create M {
        I {0 1}
        O {0 1}
        S {A B C D E F G H I}
        s A
        t {
            {A 0} D
            {A 1} B
            {B 0} E
            {B 1} C
            {C 0} F
            {C 1} C
            {D 0} G
            {D 1} E
            {E 0} H
            {E 1} F
            {F 0} I
            {F 1} F
            {G 0} G
            {G 1} H
            {H 0} H
            {H 1} I
            {I 0} I
            {I 1} I
        }
        o {
            A 0
            B 0
            C 0
            D 0
            E 0
            F 0
            G 0
            H 0
            I 1
        }
    }
    set res {}
    lappend res [M run {1 1}]
    lappend res [M run {1 1 0 0}]
    lappend res [M run {1 1 0 0 1 0 1 1}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{0 0} {0 0 0 0} {0 0 0 0 1 1 1 1}}

test fst-1.1 {edge detector} -body {
    FST create M {
        I {0 1}
        O {0 1}
        S {si s0 s1}
        s si
        t {
            {si 0} s0
            {si 1} s1
            {s0 0} s0
            {s0 1} s1
            {s1 0} s0
            {s1 1} s1
        }
        o {
            {si 0} 0
            {si 1} 0
            {s0 0} 0
            {s0 1} 1
            {s1 0} 1
            {s1 1} 0
        }
    }
    set res {}
    lappend res [M run {1 1 0}]
    lappend res [M run {0 0 1}]
    lappend res [M run {1 1 0 0 1 0 1 1}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{0 0 1} {0 0 1} {0 0 1 0 1 1 1 0}}

test fst-1.2 {edge detector} -body {
    FST create M {
        I {0 1}
        O {0 1}
        S {si s0 s1}
        s si
        t {
            {si 0} s0
            {si 1} s1
            {s0 0} s0
            {s0 1} s1
            {s1 0} s0
            {s1 1} s1
        }
        o {
            {si 0} 0
            {si 1} 0
            {s0 0} 0
            {s0 1} 1
            {s1 0} 1
            {s1 1} 0
        }
    }
    tuple2json [M tuple]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{
    "I" : ["0","1"],
    "O" : ["0","1"],
    "S" : ["si","s0","s1"],
    "s" : "si",
    "t" : {
        "si 0" : ["s0"],
        "si 1" : ["s1"],
        "s0 0" : ["s0"],
        "s0 1" : ["s1"],
        "s1 0" : ["s0"],
        "s1 1" : ["s1"]
    },
    "o" : {
        "si 0" : ["0"],
        "si 1" : ["0"],
        "s0 0" : ["0"],
        "s0 1" : ["1"],
        "s1 0" : ["1"],
        "s1 1" : ["0"]
    }
}}

test pda-1.0 {0^n1^n | n >= 0} -body {
    PDA create M {
        I {0 1}
        S {p q r}
        s p
        Z {Z A}
        z Z
        A {r}
        t {
            {p {} Z} {p q}
            {p {} A} {p q}
            {p 0 Z} p
            {p 0 A} p
            {q 1 A} q
            {q {} Z} r
        }
        o {
            {p {} Z} Z
            {p {} A} A
            {p 0 Z} {A Z}
            {p 0 A} {A A}
            {q 1 A} {}
            {q {} Z} Z
        }
    }
    set res {}
    lappend res [M run {1 1 0}]
    lappend res [M run {0 1}]
    lappend res [M run {0 0 0 1 1 1}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 1 1}

test pda-1.1 {0^n1^n | n >= 0} -body {
    PDA create M {
        I {0 1}
        S {p q r}
        s p
        Z {Z A}
        z Z
        A {r}
        t {
            {p {} Z} {p q}
            {p {} A} {p q}
            {p 0 Z} p
            {p 0 A} p
            {q 1 A} q
            {q {} Z} r
        }
        o {
            {p {} Z} Z
            {p {} A} A
            {p 0 Z} {A Z}
            {p 0 A} {A A}
            {q 1 A} {}
            {q {} Z} Z
        }
    }
    tuple2json [M tuple]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{
    "I" : ["0","1"],
    "S" : ["p","q","r"],
    "s" : "p",
    "Z" : ["Z","A"],
    "z" : "Z",
    "A" : ["r"],
    "t" : {
        "p {} Z" : ["p","q"],
        "p {} A" : ["p","q"],
        "p 0 Z"  : ["p"],
        "p 0 A"  : ["p"],
        "q 1 A"  : ["q"],
        "q {} Z" : ["r"]
    },
    "o" : {
        "p {} Z" : ["Z"],
        "p {} A" : ["A"],
        "p 0 Z"  : ["A","Z"],
        "p 0 A"  : ["A","A"],
        "q 1 A"  : [],
        "q {} Z" : ["Z"]
    }
}}

test tm-1.0 {3 state, 2 symbol busy beaver} -body {
    DTM create M {
        I {0 1}
        S {A B C HALT}
        T {0 1}
        s A
        H {HALT}
        b 0
        t {
            {A 0} B
            {A 1} C
            {B 0} A
            {B 1} B
            {C 0} B
            {C 1} HALT
        }
        o {
            {A 0} {1 R}
            {A 1} {1 L}
            {B 0} {1 L}
            {B 1} {1 R}
            {C 0} {1 L}
            {C 1} {1 R}
        }
    }
    M run
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 0 0 0 0 1 1 1 1 1 1 0 0 0}

test tm-1.1 {4 state, 2 symbol busy beaver} -body {
    DTM create M {
        I {0 1}
        S {A B C D HALT}
        T {0 1}
        s A
        H {HALT}
        b 0
        t {
            {A 0} B
            {A 1} B
            {B 0} A
            {B 1} C
            {C 0} HALT
            {C 1} D
            {D 0} D
            {D 1} A
        }
        o {
            {A 0} {1 R}
            {A 1} {1 L}
            {B 0} {1 L}
            {B 1} {0 L}
            {C 0} {1 R}
            {C 1} {1 L}
            {D 0} {1 R}
            {D 1} {0 R}
        }
    }
    M run
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}

test tm-1.2 {4 state, 2 symbol busy beaver} -body {
    DTM create M {
        I {0 1}
        S {A B C D HALT}
        T {0 1}
        s A
        H {HALT}
        b 0
        t {
            {A 0} B
            {A 1} B
            {B 0} A
            {B 1} C
            {C 0} HALT
            {C 1} D
            {D 0} D
            {D 1} A
        }
        o {
            {A 0} {1 R}
            {A 1} {1 L}
            {B 0} {1 L}
            {B 1} {0 L}
            {C 0} {1 R}
            {C 1} {1 L}
            {D 0} {1 R}
            {D 1} {0 R}
        }
    }
    tuple2json [M tuple]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{
    "I" : ["0","1"],
    "S" : ["A","B","C","D","HALT"],
    "T" : ["0","1"],
    "s" : "A",
    "H" : ["HALT"],
    "b" : "0",
    "t" : {
        "A 0" : ["B"],
        "A 1" : ["B"],
        "B 0" : ["A"],
        "B 1" : ["C"],
        "C 0" : ["HALT"],
        "C 1" : ["D"],
        "D 0" : ["D"],
        "D 1" : ["A"]
    },
    "o" : {
        "A 0" : ["1","R"],
        "A 1" : ["1","L"],
        "B 0" : ["1","L"],
        "B 1" : ["0","L"],
        "C 0" : ["1","R"],
        "C 1" : ["1","L"],
        "D 0" : ["1","R"],
        "D 1" : ["0","R"]
    }
}}

# 2-state, 2-symbol busy beaver as a Post-Turing machine
#
test ptbb-1.0 {} -body {
    PTM create M {
        C {
            begin:  J1:a
                    P R J:b
            a:      P L J:b
            b:      J1:c
                    P L J:begin
            c:      P H
        }
        b " "
        m |
        H {H}
    }
    join [M run] {}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {||||}

# 2-state, 2-symbol busy beaver as a Post-Turing machine, with cleanup
#
test ptbb-1.1 {} -body {
    PTM create M {
        C {
            begin:  J1:a
                    P R J:b
            a:      P L J:b
            b:      J1:c
                    P L J:begin
            c:      L
            d:      J0:done
                    E R J1:d
            done:   H
        }
        b { }
        m |
        H {H}
    }
    join [M run] {}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {     }

# Post-Turing machine to multiply two values
#
test ptbb-1.2 {} -body {
    PTM create M {
        C {
            R J1:*-1 R J1:*-1 R P
            L
   a_loop:  L J1:*-1 L J1:*-1 R
            E
            R J0:done
            R J1:*-1 R
   b_loop:  R
            J0:a_loop
            E
            R J1:*-1 R J1:*-1
            P
            L J1:*-1 L J1:*-1 P
            J1:b_loop
            R
            J0:a_loop
            E
   done:    H
        }
        b { }
        m |
        H {H}
    } [split { |||| |||||  } {}] 0
    join [M run] {}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {      ||||| |||||||||||||}

# 2-state, 2-symbol busy beaver as a Post-Turing machine
#
test ptbb-1.3 {} -body {
    PTM create M {
        C {
            begin:  J1:a
                    P R J:b
            a:      P L J:b
            b:      J1:c
                    P L J:begin
            c:      P H
        }
        b { }
        m |
        H {H}
    }
    tuple2json [M tuple]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{
    "C" : ["J1","6","P","R","J","10","P","L","J","10","J1","16","P","L","J","0","P","H"],
    "b" : " ",
    "m" : "|",
    "H" : ["H"]
}}





cleanupTests ; return ; # ---------------------------------



namespace import ::FSM::*

test dfa-1.0 {} -body {
    Machine M {
        input i {}
        State s0 {
            transition 0 s0
            transition 1 s1
        }
        State s1 {
            transition 0 s2
            transition 1 s0
        }
        State s2 {
            transition 0 s1
            transition 1 s2
        }
        start s0
        accept {in {s0}}
    }
    M run
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1

test dfa-1.1 {} -body {
    Machine M {
        input i {}
        State s0 {
            transition 0 s0
            transition 1 s1
        }
        State s1 {
            transition 0 s2
            transition 1 s0
        }
        State s2 {
            transition 0 s1
            transition 1 s2
        }
        start s0
        accept {in {s0}}
    }
    set res {}
    M set input i {1}
    lappend res [M run]
    M set input i {0 1}
    lappend res [M run]
    M set input i {1 1}
    lappend res [M run]
    M set input i {0 0 1}
    lappend res [M run]
    M set input i {1 0 1}
    lappend res [M run]
    M set input i {0 1 1}
    lappend res [M run]
    M set input i {1 1 1}
    lappend res [M run]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 0 1 0 0 1 0}

test nfa-1.0 {} -body {
    Machine M {
        input i {}
        State s0 {
            transition 0 s0
            transition 1 s0
            transition 1 s1
        }
        State s1 {
            transition 0 s0
            transition 1 s1
        }
        start s0
        accept {in {s1}}
    }
    set res {}
    M set input i {1}
    lappend res [M run]
    M set input i {0}
    lappend res [M run]
    M set input i {1 1}
    lappend res [M run]
    M set input i {1 0}
    lappend res [M run]
    M set input i {0 1}
    lappend res [M run]
    M set input i {0 0}
    lappend res [M run]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 1 0 1 0}

test nfa-1.1 {find even number of ones/zeros} -body {
    Machine M {
        State s0 {
            transition ε s1
            transition ε s3
        }
        State s1 {
            transition 0 s2
            transition 1 s1
        }
        State s2 {
            transition 0 s1
            transition 1 s2
        }
        State s3 {
            transition 0 s3
            transition 1 s4
        }
        State s4 {
            transition 0 s4
            transition 1 s3
        }
        start s0
        accept {in {s1 s3}}
    }
    set res {}
    M set input i {1 1}
    lappend res [M run]
    M set input i {1 0}
    lappend res [M run]
    M set input i {0 1}
    lappend res [M run]
    M set input i {0 0}
    lappend res [M run]
    M set input i {1 0 0 1 1 1}
    lappend res [M run]
    M set input i {1 0 0 1 1 0}
    lappend res [M run]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 0 1 1 0}




cleanupTests ; return ; # ---------------------------------
