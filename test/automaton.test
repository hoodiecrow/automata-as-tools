package require tcltest
namespace import ::tcltest::*

::tcltest::configure {*}$argv

::tcltest::testConstraint noskip 1

::tcltest::loadTestedCommands

package require automaton

test dfa-1.0 {accept binary numbers that are multiples of 3} -body {
    FSM create M {
        I {0 1}
        S {s0 s1 s2}
        s s0
        t {
            {s0 0} s0
            {s0 1} s1
            {s1 0} s2
            {s1 1} s0
            {s2 0} s1
            {s2 1} s2
        }
        A s0
    }
    M show
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{
    "I" : ["0","1"],
    "S" : ["s0","s1","s2"],
    "s" : "s0",
    "t" : {
        "s0 0" : ["s0"],
        "s0 1" : ["s1"],
        "s1 0" : ["s2"],
        "s1 1" : ["s0"],
        "s2 0" : ["s1"],
        "s2 1" : ["s2"]
    },
    "A" : ["s0"]
}}

test dfa-1.1 {} -body {
    FSM create M {
        json {
            {
                "I": [0, 1],
                "S": ["s0", "s1", "s2"],
                "s": "s0",
                "t": {
                    "s0 0": "s0",
                    "s0 1": "s1",
                    "s1 0": "s2",
                    "s1 1": "s0",
                    "s2 0": "s1",
                    "s2 1": "s2"
                },
                "A": "s0"
            }
        }
    }
    set res {}
    lappend res [M run {1}]
    lappend res [M run {0 1}]
    lappend res [M run {1 1}]
    lappend res [M run {0 0 1}]
    lappend res [M run {1 0 1}]
    lappend res [M run {0 1 1}]
    lappend res [M run {1 1 1}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 0 1 0 0 1 0}

test nfa-1.0 {} -body {
    FSM create M {
        I {0 1}
        S {s0 s1 s2}
        s s0
        t {
            {s0 0} s0
            {s0 1} {s0 s1}
            {s1 0} s0
            {s1 1} s1
        }
        A s1
    }
    set res {}
    lappend res [M run {1}]
    lappend res [M run {0}]
    lappend res [M run {1 1}]
    lappend res [M run {1 0}]
    lappend res [M run {0 1}]
    lappend res [M run {0 0}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 1 0 1 0}

test nfa-1.1 {find even number of ones/zeros} -body {
    FSM create M {
        I {0 1}
        S {s0 s1 s2 s3 s4}
        s s0
        t {
            {s0 {}} {s1 s3}
            {s1 0} s2
            {s1 1} s1
            {s2 0} s1
            {s2 1} s2
            {s3 0} s3
            {s3 1} s4
            {s4 0} s4
            {s4 1} s3
        }
        A {s1 s3}
    }
    set res {}
    lappend res [M run {1 1}]
    lappend res [M run {1 0}]
    lappend res [M run {0 1}]
    lappend res [M run {0 0}]
    lappend res [M run {1 0 0 1 1 1}]
    lappend res [M run {1 0 0 1 1 0}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 0 1 1 0}

test fst-1.0 {The output becomes 1 and remains 1 thereafter when at least two 0's and two 1's have occurred as inputs} -body {
    FST create M {
        I {0 1}
        O {0 1}
        S {A B C D E F G H I}
        s A
        t {
            {A 0} D
            {A 1} B
            {B 0} E
            {B 1} C
            {C 0} F
            {C 1} C
            {D 0} G
            {D 1} E
            {E 0} H
            {E 1} F
            {F 0} I
            {F 1} F
            {G 0} G
            {G 1} H
            {H 0} H
            {H 1} I
            {I 0} I
            {I 1} I
        }
        o {
            A 0
            B 0
            C 0
            D 0
            E 0
            F 0
            G 0
            H 0
            I 1
        }
    }
    set res {}
    lappend res [M run {1 1} ; M output]
    lappend res [M run {1 1 0 0} ; M output]
    lappend res [M run {1 1 0 0 1 0 1 1} ; M output]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{0 0} {0 0 0 0} {0 0 0 0 1 1 1 1}}

test fst-1.1 {edge detector} -body {
    FST create M {
        I {0 1}
        O {0 1}
        S {si s0 s1}
        s si
        t {
            {si 0} s0
            {si 1} s1
            {s0 0} s0
            {s0 1} s1
            {s1 0} s0
            {s1 1} s1
        }
        o {
            {si 0} 0
            {si 1} 0
            {s0 0} 0
            {s0 1} 1
            {s1 0} 1
            {s1 1} 0
        }
    }
    set res {}
    lappend res [M run {1 1 0} ; M output]
    lappend res [M run {0 0 1} ; M output]
    lappend res [M run {1 1 0 0 1 0 1 1} ; M output]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{0 0 1} {0 0 1} {0 0 1 0 1 1 1 0}}

test fst-1.2 {edge detector} -body {
    FST create M {
        I {0 1}
        O {0 1}
        S {si s0 s1}
        s si
        t {
            {si 0} s0
            {si 1} s1
            {s0 0} s0
            {s0 1} s1
            {s1 0} s0
            {s1 1} s1
        }
        o {
            {si 0} 0
            {si 1} 0
            {s0 0} 0
            {s0 1} 1
            {s1 0} 1
            {s1 1} 0
        }
    }
    M show
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{
    "I" : ["0","1"],
    "O" : ["0","1"],
    "S" : ["si","s0","s1"],
    "s" : "si",
    "t" : {
        "si 0" : ["s0"],
        "si 1" : ["s1"],
        "s0 0" : ["s0"],
        "s0 1" : ["s1"],
        "s1 0" : ["s0"],
        "s1 1" : ["s1"]
    },
    "o" : {
        "si 0" : ["0"],
        "si 1" : ["0"],
        "s0 0" : ["0"],
        "s0 1" : ["1"],
        "s1 0" : ["1"],
        "s1 1" : ["0"]
    }
}}

test pda-1.0 {0^n1^n | n >= 0} -body {
    PDA create M {
        I {0 1}
        S {p q r}
        s p
        Z {Z A}
        z Z
        A {r}
        t {
            {p {} Z} {p q}
            {p {} A} {p q}
            {p 0 Z} p
            {p 0 A} p
            {q 1 A} q
            {q {} Z} r
        }
        o {
            {p {} Z} Z
            {p {} A} A
            {p 0 Z} {A Z}
            {p 0 A} {A A}
            {q 1 A} {}
            {q {} Z} Z
        }
    }
    set res {}
    lappend res [M run {1 1 0}]
    lappend res [M run {0 1}]
    lappend res [M run {0 0 0 1 1 1}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 1 1}

test pda-1.1 {0^n1^n | n >= 0} -body {
    PDA create M {
        I {0 1}
        S {p q r}
        s p
        Z {Z A}
        z Z
        A {r}
        t {
            {p {} Z} {p q}
            {p {} A} {p q}
            {p 0 Z} p
            {p 0 A} p
            {q 1 A} q
            {q {} Z} r
        }
        o {
            {p {} Z} Z
            {p {} A} A
            {p 0 Z} {A Z}
            {p 0 A} {A A}
            {q 1 A} {}
            {q {} Z} Z
        }
    }
    M show
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{
    "I" : ["0","1"],
    "S" : ["p","q","r"],
    "s" : "p",
    "Z" : ["Z","A"],
    "z" : "Z",
    "A" : ["r"],
    "t" : {
        "p {} Z" : ["p","q"],
        "p {} A" : ["p","q"],
        "p 0 Z"  : ["p"],
        "p 0 A"  : ["p"],
        "q 1 A"  : ["q"],
        "q {} Z" : ["r"]
    },
    "o" : {
        "p {} Z" : ["Z"],
        "p {} A" : ["A"],
        "p 0 Z"  : ["A","Z"],
        "p 0 A"  : ["A","A"],
        "q 1 A"  : [],
        "q {} Z" : ["Z"]
    }
}}

test tm-1.0 {3 state, 2 symbol busy beaver} -body {
    TM create M {
        I {0 1}
        S {A B C HALT}
        T {0 1}
        s A
        H {HALT}
        b 0
        t {
            {A 0} B
            {A 1} C
            {B 0} A
            {B 1} B
            {C 0} B
            {C 1} HALT
        }
        o {
            {A 0} {1 R}
            {A 1} {1 L}
            {B 0} {1 L}
            {B 1} {1 R}
            {C 0} {1 L}
            {C 1} {1 R}
        }
    }
    M run
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 0 0 0 0 1 1 1 1 1 1 0 0 0}

test tm-1.1 {4 state, 2 symbol busy beaver} -body {
    TM create M {
        I {0 1}
        S {A B C D HALT}
        T {0 1}
        s A
        H {HALT}
        b 0
        t {
            {A 0} B
            {A 1} B
            {B 0} A
            {B 1} C
            {C 0} HALT
            {C 1} D
            {D 0} D
            {D 1} A
        }
        o {
            {A 0} {1 R}
            {A 1} {1 L}
            {B 0} {1 L}
            {B 1} {0 L}
            {C 0} {1 R}
            {C 1} {1 L}
            {D 0} {1 R}
            {D 1} {0 R}
        }
    }
    M run
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}

test tm-1.2 {4 state, 2 symbol busy beaver} -body {
    TM create M {
        I {0 1}
        S {A B C D HALT}
        T {0 1}
        s A
        H {HALT}
        b 0
        t {
            {A 0} B
            {A 1} B
            {B 0} A
            {B 1} C
            {C 0} HALT
            {C 1} D
            {D 0} D
            {D 1} A
        }
        o {
            {A 0} {1 R}
            {A 1} {1 L}
            {B 0} {1 L}
            {B 1} {0 L}
            {C 0} {1 R}
            {C 1} {1 L}
            {D 0} {1 R}
            {D 1} {0 R}
        }
    }
    M show
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{
    "I" : ["0","1"],
    "S" : ["A","B","C","D","HALT"],
    "T" : ["0","1"],
    "s" : "A",
    "H" : ["HALT"],
    "b" : "0",
    "t" : {
        "A 0" : ["B"],
        "A 1" : ["B"],
        "B 0" : ["A"],
        "B 1" : ["C"],
        "C 0" : ["HALT"],
        "C 1" : ["D"],
        "D 0" : ["D"],
        "D 1" : ["A"]
    },
    "o" : {
        "A 0" : ["1","R"],
        "A 1" : ["1","L"],
        "B 0" : ["1","L"],
        "B 1" : ["0","L"],
        "C 0" : ["1","R"],
        "C 1" : ["1","L"],
        "D 0" : ["1","R"],
        "D 1" : ["0","R"]
    }
}}





cleanupTests ; return ; # ---------------------------------



namespace import ::FSM::*

test dfa-1.0 {} -body {
    Machine M {
        input i {}
        State s0 {
            transition 0 s0
            transition 1 s1
        }
        State s1 {
            transition 0 s2
            transition 1 s0
        }
        State s2 {
            transition 0 s1
            transition 1 s2
        }
        start s0
        accept {in {s0}}
    }
    M run
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1

test dfa-1.1 {} -body {
    Machine M {
        input i {}
        State s0 {
            transition 0 s0
            transition 1 s1
        }
        State s1 {
            transition 0 s2
            transition 1 s0
        }
        State s2 {
            transition 0 s1
            transition 1 s2
        }
        start s0
        accept {in {s0}}
    }
    set res {}
    M set input i {1}
    lappend res [M run]
    M set input i {0 1}
    lappend res [M run]
    M set input i {1 1}
    lappend res [M run]
    M set input i {0 0 1}
    lappend res [M run]
    M set input i {1 0 1}
    lappend res [M run]
    M set input i {0 1 1}
    lappend res [M run]
    M set input i {1 1 1}
    lappend res [M run]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 0 1 0 0 1 0}

test nfa-1.0 {} -body {
    Machine M {
        input i {}
        State s0 {
            transition 0 s0
            transition 1 s0
            transition 1 s1
        }
        State s1 {
            transition 0 s0
            transition 1 s1
        }
        start s0
        accept {in {s1}}
    }
    set res {}
    M set input i {1}
    lappend res [M run]
    M set input i {0}
    lappend res [M run]
    M set input i {1 1}
    lappend res [M run]
    M set input i {1 0}
    lappend res [M run]
    M set input i {0 1}
    lappend res [M run]
    M set input i {0 0}
    lappend res [M run]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 1 0 1 0}

test nfa-1.1 {find even number of ones/zeros} -body {
    Machine M {
        State s0 {
            transition ε s1
            transition ε s3
        }
        State s1 {
            transition 0 s2
            transition 1 s1
        }
        State s2 {
            transition 0 s1
            transition 1 s2
        }
        State s3 {
            transition 0 s3
            transition 1 s4
        }
        State s4 {
            transition 0 s4
            transition 1 s3
        }
        start s0
        accept {in {s1 s3}}
    }
    set res {}
    M set input i {1 1}
    lappend res [M run]
    M set input i {1 0}
    lappend res [M run]
    M set input i {0 1}
    lappend res [M run]
    M set input i {0 0}
    lappend res [M run]
    M set input i {1 0 0 1 1 1}
    lappend res [M run]
    M set input i {1 0 0 1 1 0}
    lappend res [M run]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 0 1 1 0}




cleanupTests ; return ; # ---------------------------------




test pda-1.0 {} -body {
    ::automaton::PDA create M {
        {p 0 Z p A Z}
        {p 0 A p A A}
        {p ε Z q Z}
        {p ε A q A}
        {q 1 A q ε}
        {q ε Z r Z}
    }
    set res {}
    lappend res [M accept {p} {0 1} {Z} {r}]
    lappend res [M accept {p} {0 0 0 1 1 1} {Z} {r}]
    lappend res [M accept {p} {0 0 0 1 1} {Z} {r}]
    lappend res [M accept {p} {0 0 0 1 1 1 1} {Z} {r}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 1 0 0}

test pda-1.1 {} -body {
    ::automaton::PDA create M {
        {p 0 Z p A Z}
        {p 0 A p A A}
        {p ε Z q Z}
        {p ε A q A}
        {q 1 A q ε}
        {q ε Z r Z}
    } {p pee q que r ar}
    M accept {p} {0 0 0 1 1 1} {Z} {r}
    M output
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {pee pee pee pee que que que ar}

test pda-1.2 {} -body {
    ::automaton::PDA create M {
        {p 0 Z p A Z}
        {p 0 A p A A}
        {p ε Z q Z}
        {p ε A q A}
        {q 1 A q ε}
        {q ε Z r Z}
    } {
        p,0,A pee0A
        p,0,Z pee0Z
        p,1,A pee1A
        p,1,Z pee1Z
        q,0,A que0A
        q,0,Z que0Z
        q,1,A que1A
        r,,Z  done
    }
    M accept {p} {0 0 0 1 1 1} {Z} {r}
    M output
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {pee0Z pee0A pee0A pee1A que1A que1A done}

test pda-1.3 {} -body {
    ::automaton::PDA create M {
        {p 0 Z p A Z}
        {p 0 A p A A}
        {p ε Z q Z}
        {p ε A q A}
        {q 1 A q ε}
        {q ε Z r Z}
    } {
        p,0,A pee0A
        p,0,Z pee0Z
        p,1,A pee1A
        p,1,Z pee1Z
        q,0,A que0A
        q,0,Z que0Z
        q,1,A que1A
        r,,Z  done
    }
    M accept {p} {{0 foo} 0 0 {1 bar baz} 1 1} {Z} {r}
    M output
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{pee0Z foo} pee0A pee0A {pee1A bar baz} que1A que1A done}

test tape-1.0 {} -body {
    ::automaton::Tape create foo a b c
    oo::objdefine foo export variable
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a b c} 2}

test tape-1.1 {} -body {
    ::automaton::Tape create foo a b c
    foo R ; foo L ; foo L ; foo L ; foo L
    oo::objdefine foo export variable
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{_ a b c _} 0}

test tape-1.2 {} -body {
    ::automaton::Tape create foo -length 4 a b c
    foo R ; foo L ; foo L ; foo L ; foo L
    oo::objdefine foo export variable
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a b c _} 0}

test tape-1.3 {} -body {
    ::automaton::Tape create foo -length 3 a b c
    foo R ; foo L ; foo L ; foo L ; foo L
    oo::objdefine foo export variable
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a b c} 0}

test tape-1.4 {} -body {
    ::automaton::Tape create foo a b c
    foo L ; foo set x
    oo::objdefine foo export variable
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a x c} 1}

test tape-1.5 {} -body {
    ::automaton::Tape create foo a b c
    foo L ; foo erase
    oo::objdefine foo export variable
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a _ c} 1}

test tape-1.6 {} -body {
    ::automaton::Tape create foo -blank X a b c
    foo L ; foo erase
    oo::objdefine foo export variable
    foo variable data head
    list $data $head [foo get]
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a X c} 1 X}

test tape-1.7 {} -body {
    ::automaton::Tape create foo -start 2 a b c d e
    oo::objdefine foo export variable CutLeft
    foo CutLeft
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{d e} 0}

test tape-1.8 {} -body {
    ::automaton::Tape create foo -start 2 a b c d e
    oo::objdefine foo export variable CutRight
    foo CutRight
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a b} 1}

test tape-1.9 {} -body {
    ::automaton::Tape create foo -leftbound 1 -start 0 a b c
    foo L
    oo::objdefine foo export variable
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a b c} 0}

test tape-1.10 {} -body {
    ::automaton::Tape create foo -rightbound 3 a b c
    foo R ; foo R ; foo R
    oo::objdefine foo export variable
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a b c} 2}

test tape-1.11 {} -body {
    ::automaton::Tape create foo -values {a {b 1} c} a b x c
} -cleanup {
    log::lvSuppressLE i 1
} -result {illegal tape value "x" not in "a, b, c"} -returnCodes error

test tape-1.12 {} -body {
    ::automaton::Tape create foo -values {a b c} -endmarkers {< >} -fill 7 a b c
    oo::objdefine foo export variable
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{< a b c _ _ _ _ >} 1}


test stack-1.0 {} -body {
    ::automaton::Stack create foo
    oo::objdefine foo export variable
    foo variable data head
    list $data $head [foo top]
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{{}} 0 {}}

test stack-1.1 {} -body {
    ::automaton::Stack create foo a b c
    oo::objdefine foo export variable
    foo variable data head
    list $data $head [foo top]
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a b c} 2 c}

test stack-1.2 {} -body {
    ::automaton::Stack create foo a b c
    foo pop
    oo::objdefine foo export variable
    foo variable data head
    list $data $head [foo top]
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a b} 1 b}

test stack-1.3 {} -body {
    ::automaton::Stack create foo a b c
    foo pop ; foo pop ; foo pop
    oo::objdefine foo export variable
    foo variable data head
    list $data $head [foo top]
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {a 0 a}

test stack-1.4 {} -body {
    ::automaton::Stack create foo a b c
    foo pop ; foo pop ; foo pop
    foo push x y
    oo::objdefine foo export variable
    foo variable data head
    list $data $head [foo top]
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a x y} 2 y}

test stack-1.5 {} -body {
    ::automaton::Stack create foo a b c
    foo adjust
    oo::objdefine foo export variable
    foo variable data head
    list $data $head [foo top]
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a b} 1 b}

test stack-1.6 {} -body {
    ::automaton::Stack create foo a b c
    foo adjust q
    oo::objdefine foo export variable
    foo variable data head
    list $data $head [foo top]
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a b q} 2 q}

test stack-1.7 {} -body {
    ::automaton::Stack create foo a b c
    foo adjust q r s
    oo::objdefine foo export variable
    foo variable data head
    list $data $head [foo top]
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a b s r q} 4 q}

test input-1.0 {} -body {
    ::automaton::Input create foo a b c
    oo::objdefine foo export variable
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a b c ε} 0}

test input-1.1 {} -body {
    ::automaton::Input create foo -empty E a b c
    oo::objdefine foo export variable
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a b c E} 0}

test input-1.2 {} -body {
    ::automaton::Input create foo -empty E a b c
    set res {}
    for {set i 0} {$i < 5} {incr i} {
        lappend res [foo get]
    }
    oo::objdefine foo export variable
    foo variable data head
    list $data $head $res
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {{a b c E} 3 {a b c E E}}

test input-1.3 {} -body {
    ::automaton::Input create foo -empty E
    oo::objdefine foo export variable
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {E 0}

test state-1.0 {} -body {
    ::automaton::State create foo -accept {a b} -values {a b c d e} -default e
    oo::objdefine foo export variable
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {e 0}

test state-1.1 {} -body {
    ::automaton::State create foo -accept {a b} -values {a b c d e} -default e
    foo set c
    oo::objdefine foo export variable
    foo variable data head
    list $data $head [foo accept]
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {c 0 0}

test state-1.2 {} -body {
    ::automaton::State create foo -accept {a b} -values {a b c d e} -default e
    foo set a
    oo::objdefine foo export variable
    foo variable data head
    list $data $head [foo accept]
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {a 0 1}

test state-1.3 {} -body {
    ::automaton::State create foo -accept {a x} -values {a b c d e} -default e
} -cleanup {
    log::lvSuppressLE i 1
} -result {illegal accepting state(s) (x)} -returnCodes error

test state-1.4 {} -body {
    ::automaton::State create foo -accept {a b} -values {a b c d e} e d c
    oo::objdefine foo export variable
    foo variable data head
    list $data $head
} -cleanup {
    unset data head
    foo destroy
    log::lvSuppressLE i 1
} -result {c 0}

proc nextState {tuple delim args} {
    set wms [split $tuple $delim]
    set c {}
    catch { set c [$::counter get] }
    log::log d "($c: [$::tape get],[$::state get],[join $wms ,]) : $args"
    catch { $::counter incr }
    return $wms
}

# 1-state, 2-symbol busy beaver
#
#   A
# 0 1,R,H
# 1 ---
# 
# Result: 0 0 1 0 0 (1 step, one "1" total)
test bb-1.0 {} -body {
    set tape  [::automaton::Tape new -values {0 1} -blank 0 -start 2 -endmarkers {< >} -fill 5]
    set state [::automaton::State new -values {A B H} A]
    set matrix {
        0,A {1 R H}
        1,A {- - -}
    }
    oo::objdefine $tape export variable
    $tape variable data head
    while {[$state get] ne "H"} {
        lassign [dict get $matrix [$tape get],[$state get]] w m s
        [$tape set $w] $m
        $state set $s
    }
    list $data $head
} -cleanup {
    unset data head
    $tape destroy
    $state destroy
    log::lvSuppressLE i 1
} -result {{< 0 0 1 0 0 >} 4}

# 2-state, 2-symbol busy beaver
#
#   A      B
# 0 1,R,B  1,L,A
# 1 1,L,B  1,R,H
# 
# Result: 0 0 1 1 1 1 0 0 (6 steps, four "1"s total)
test bb-1.1 {} -body {
    set tape  [::automaton::Tape new -values {0 1} -blank 0 -start 4 -endmarkers {< >} -fill 8]
    set state [::automaton::State new -values {A B H} A]
    set counter [::automaton::State new -limit 6 0]
    set matrix [dict create {*}{
        0,A {1 R B} 0,B {1 L A}
        1,A {1 L B} 1,B {1 R H}
    }]
    oo::objdefine $tape export variable
    $tape variable data head
    while {[$state get] ne "H"} {
        lassign [dict get $matrix [$tape get],[$state get]] w m s
        [$tape set $w] $m
        $state set $s
        $counter incr
    }
    list $data $head
} -cleanup {
    unset data head
    $tape destroy
    $state destroy
    $counter destroy
    log::lvSuppressLE i 1
} -result {{< 0 0 1 1 1 1 0 0 >} 5}

# 3-state, 2-symbol busy beaver
#
#   A      B      C
# 0 1,R,B  0,R,C  1,L,C
# 1 1,R,H  1,R,B  1,L,A
# 
# Result: 0 0 1 1 1 1 1 1 0 0 (14 steps, six "1"s total).
test bb-1.2 {} -body {
    set tape  [::automaton::Tape new -values {0 1} -blank 0 -start 3 -endmarkers {< >} -fill 10]
    set state [::automaton::State new -values {A B C H} A]
    set counter [::automaton::State new -limit 14 0]
    set matrix [dict create {*}{
        0,A {1 R B} 0,B {0 R C} 0,C {1 L C}
        1,A {1 R H} 1,B {1 R B} 1,C {1 L A}
    }]
    oo::objdefine $tape export variable
    $tape variable data head
    while {[$state get] ne "H"} {
        lassign [dict get $matrix [$tape get],[$state get]] w m s
        [$tape set $w] $m
        $state set $s
        $counter incr
    }
    list $data $head
} -cleanup {
    unset data head
    $tape destroy
    $state destroy
    $counter destroy
    log::lvSuppressLE i 1
} -result {{< 0 0 1 1 1 1 1 1 0 0 >} 6}

# 4-state, 2-symbol busy beaver

#   A   B   C   D
# 0 1RB 1LA 1RH 1RD 
# 1 1LB 0LC 1LD 0RA 
# 
# Result: 0 0 1 0 1 1 1 1 1 1 1 1 1 1 1 1 0 0 (107 steps, thirteen "1"s total)
test bb-1.3 {} -body {
    set tape  [::automaton::Tape new -values {0 1} -blank 0 -start 12 -endmarkers {< >} -fill 18]
    set state [::automaton::State new -values {A B C D H} A]
    set counter [::automaton::State new -limit 107 0]
    set matrix [dict create {*}{
        0,A {1 R B} 0,B {1 L A} 0,C {1 R H} 0,D {1 R D}
        1,A {1 L B} 1,B {0 L C} 1,C {1 L D} 1,D {0 R A}
    }]
    oo::objdefine $tape export variable
    $tape variable data head
    while {[$state get] ne "H"} {
        lassign [dict get $matrix [$tape get],[$state get]] w m s
        [$tape set $w] $m
        $state set $s
        $counter incr
    }
    list $data $head
} -cleanup {
    unset data head
    $tape destroy
    $state destroy
    $counter destroy
    log::lvSuppressLE i 1
} -result {{< 0 0 1 0 1 1 1 1 1 1 1 1 1 1 1 1 0 0 >} 4}

# 2-state, 2-symbol busy beaver as a Post-Turing machine
#
# Instruction # 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14
# Instruction   J1 P  R  J  P  L  J  J1 P  L  J   P   N   J   H 
# Jump-to #     4        7        7  11       0           14  
# 
test ptbb-1.0 {} -body {
    set tape [::automaton::Tape new -values {0 1} -blank 0 -start 4 -endmarkers {< >} -fill 8]
    set program [::automaton::Tape new \
        -values {H J J1 L N P R} \
        -start 0 \
        -endmarkers {< >} \
        {J1 4} P R {J 7} P L {J 7} {J1 11} P L {J 0} P N {J 14} H]
    oo::objdefine $program export variable
    $program variable data head
    while {[$program get] ne "H"} {
        set p [$program get]
        log::log d [format {%-2s: %s} $head $p]
        switch [lindex $p 0] {
            P { $tape set 1 ; $program R }
            E { $tape erase ; $program R }
            L - R { $tape $p ; $program R }
            N { $program R }
            J { $program J [lindex $p 1]}
            J1 { if {[$tape get] eq 1} {$program J [lindex $p 1]} {$program R}}
        }
    }
    unset data head
    oo::objdefine $tape export variable
    $tape variable data head
    list $data $head
} -cleanup {
    unset data head
    $tape destroy
    $program destroy
    log::lvSuppressLE i 1
} -result {{< 0 0 1 1 1 1 0 0 >} 4}

# 2-state, 2-symbol busy beaver as a Post-Turing machine, with cleanup
#
# Instruction # 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14
# Instruction   J1 P  R  J  P  L  J  J1 P  L  J   P   N   J   H 
# Jump-to #     4        7        7  11       0           14  
# 
test ptbb-1.1 {} -body {
    set tape [::automaton::Tape new \
        -values {0 1} \
        -blank 0 \
        -start 4 \
        -endmarkers {< >} \
        -fill 8 \
        ]
    set program [::automaton::Tape new \
        -values {E G G0 G1 H J J0 J1 L N P R} \
        -start 0 \
        -endmarkers {< >} \
        {J1 4} P R {J 7} P L {J 7} {J1 11} P L {J 0} P N {J 14} L {J0 19} E R {J1 16} H]
    oo::objdefine $program export variable
    $program variable data head
    while 1 {
        set p [$program get]
        log::log d [format {%-2s: %s} $head $p]
        switch [lindex $p 0] {
            H { break }
            P { $tape set 1 ; $program R }
            E { $tape erase ; $program R }
            L - R { $tape $p ; $program R }
            N { $program R }
            G { $tape J [lindex $p 1] ; $program R }
            G0 { if {[$tape get] eq 0} {$tape J [lindex $p 1]} {$program R}}
            G1 { if {[$tape get] eq 1} {$tape J [lindex $p 1]} {$program R}}
            J { $program J [lindex $p 1]}
            J0 { if {[$tape get] eq 0} {$program J [lindex $p 1]} {$program R}}
            J1 { if {[$tape get] eq 1} {$program J [lindex $p 1]} {$program R}}
        }
    }
    unset data head
    oo::objdefine $tape export variable
    $tape variable data head
    list $data $head
} -cleanup {
    unset data head
    $tape destroy
    $program destroy
    log::lvSuppressLE i 1
} -result {{< 0 0 0 0 0 0 0 0 >} 7}

# Post-Turing machine to multiply two values
#
proc fixJumps items {
    set map {}
    set code {}
    set n 0
    foreach item $items {
        if {[string match *: $item]} {
            lappend map [string trimright $item :] $n
        } else {
            lappend code $item
            incr n
        }
    }
    string map $map $code
}

test ptbb-1.2 {} -body {
    set tape [::automaton::Tape new \
        -values {0 1} \
        -blank 0 \
        -start 4 \
        0 1 1 1 1 0 1 1 1 1 1 0 0]
    set program [::automaton::Tape new \
        -values {E H J J0 J1 L N P R} \
        -start 0 \
        -endmarkers {< >} \
        {*}[fixJumps {
            R {J1 *-1} R {J1 *-1} R P
            L
   a_loop:  L {J1 *-1} L {J1 *-1} R
            E
            R {J0 done}
            R {J1 *-1} R
   b_loop:  R
            {J0 a_loop}
            E
            R {J1 *-1} R {J1 *-1}
            P
            L {J1 *-1} L {J1 *-1} P
            {J1 b_loop}
            R
            {J0 a_loop}
            E
   done:    H
        }]]
    oo::objdefine $program export variable
    $program variable data head
    while 1 {
        set p [$program get]
        log::log d [format {%-2s: %s} $head $p]
        switch [lindex $p 0] {
            E { $tape erase ; $program R }
            H { break }
            J { $program J [lindex $p 1]}
            J0 { if {[$tape get] eq 0} {$program J [lindex $p 1]} {$program R} }
            J1 { if {[$tape get] eq 1} {$program J [lindex $p 1]} {$program R} }
            L - R { $tape $p ; $program R }
            N { $program R }
            P { $tape set 1 ; $program R }
        }
    }
    unset data head
    oo::objdefine $tape export variable
    $tape variable data head
    list $data $head
} -cleanup {
    unset data head
    $tape destroy
    $program destroy
    log::lvSuppressLE i 1
} -result {{0 0 0 0 0 0 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1} 5}

cleanupTests ; return
