package require tcltest
namespace import ::tcltest::*

::tcltest::configure {*}$argv

::tcltest::testConstraint noskip 1

::tcltest::loadTestedCommands

package require automata::fst

set t {::automata::FST create M}

test fst-1.0 {} -setup $t -body {
    M compile {
        0 a/a 1
        1 b/b 0
    }
    M S set 0
    M F set 0
    M generate 4
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{a b a b} 0 {a b a b}}}

test fst-1.1 {} -setup $t -body {
    M compile {
        0 a/a 1
        1 b/b 2
        2 ε/c 0
    }
    M S set 0
    M F set 0
    M generate 6
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {{{a b a b} 0 {a b c a b c}}}

test fst-1.2 {} -setup $t -body {
    M compile {
        0 a/a 1
        0 b/d 2
        1 b/b 2
        2 ε/c 0
    }
    M S set 0
    M F set 0 1 2
    M generate 6
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {{{a b a b} 0 {a b c a b c}} {{a b b a} 1 {a b c d c a}} {{a b b b} 2 {a b c d c d}} {{b a b a} 1 {d c a b c a}} {{b a b b} 2 {d c a b c d}} {{b b a b} 2 {d c d c a b}} {{b b b} 0 {d c d c d c}}}

test fst-2.0 {} -setup $t -body {
    M compile {
        0 a/a 1
        1 b/b 0
    }
    M S set 0
    M F set 0
    set res {}
    lappend res [M recognize {a b a b} {a b a b}]
    lappend res [M recognize {a b a b} {a b a c}]
    set res
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {1 0}

test fst-2.1 {} -setup $t -body {
    M compile {
        0 a/a 1
        1 b/b 2
        2 ε/c 0
    }
    M S set 0
    M F set 0
    set res {}
    lappend res [M recognize {a b a b} {a b c a b c}]
    lappend res [M recognize {a b a b} {a b a b c}]
    set res
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {1 0}

test generate-1.0 {} -setup $t -body {
    M compile {
        1 a/a 2
        2 ε/a 1
    }
    M S set 1
    M F set 1
    M generate 4
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{a a} 1 {a a a a}}}

test generate-1.1 {} -setup $t -body {
    M compile {
        1 ε/  2
        1 a/a 3
        2 a/b 3
        3 ε/a 1
    }
    M S set 1
    M F set 1 2 3
    lsort [M generate 4]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{a 2 {b a}} {{a a} 1 {a a a a}} {{a a} 3 {a a b}} {{a a} 3 {b a a}}}

test recognize-1.0 {recognize relation {a b} -> {x y}} -setup $t -body {
    M compile {
        1 a/x 1
        1 b/y 2
        2 ε/  1
    }
    M S set 1
    M F set 1
    M recognize {a a} {x x}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1

test recognize-1.1 {recognize relation {a b} -> {x (y y)}} -setup $t -body {
    M compile {
        1 a/x 1
        1 b/y 2
        2 ε/y 1
    }
    M S set 1
    M F set 1
    set res {}
    lappend res [M recognize {a b a} {x y y x}]
    lappend res [M recognize {b a a b} {y y x x y}]
    lappend res [M recognize {a b a b} {x y y x y y}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 1}

test recognize-1.2 {recognize {a*(b+c+)?} relation {a b c} -> {x y z}} -setup $t -body {
    M compile {
        1 a/x 1
        1 b/y 2
        2 b/y 2
        2 c/z 3
        3 c/z 3
        3 ε/  1
    }
    M S set 1
    M F set 1
    set res {}
    lappend res [M recognize {a b c} {x y z}]
    lappend res [M recognize {a c b} {x z x}]
    lappend res [M recognize {a b b c c a b c} {x y y z z x y z}]
    lappend res [M recognize {a b c} {x x x}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 1 0}

test dfst-1.0 {} -setup $t -body {
    M compile {
        1 a/a 2
        2 ε/a 1
    }
    M S set 1
    M F set 1
    M generate 4
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{a a} 1 {a a a a}}}


test dfst-1.1 {} -setup $t -body {
    M compile {
        1 a/a 2
        2 ε/a 1
    }
    M S set 1
    M F set 1
    M recognize {a a} {a a a a}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1


test dfst-1.2 {} -setup $t -body {
    M compile {
        1 a/a 2
        2 ε/a 1
    }
    M S set 1
    M F set 1
    M translate {a a}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{a a a a}}


test dfst-1.3 {} -setup $t -body {
    M compile {
        1 a/a 2
        2 ε/a 1
    }
    M S set 1
    M F set 1
    M reconstruct {a a a a}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{a a}}

test dfst-2.0 {The output becomes 1 and remains 1 thereafter when at least two 0's and two 1's have occurred as inputs} -setup $t -body {
    M compile {
        A 0/0 D
        A 1/0 B
        B 0/0 E
        B 1/0 C
        C 0/0 F
        C 1/0 C
        D 0/0 G
        D 1/0 E
        E 0/0 H
        E 1/0 F
        F 0/0 I
        F 1/0 F
        G 0/0 G
        G 1/0 H
        H 0/0 H
        H 1/0 I
        I 0/1 I
        I 1/1 I
    }
    M S set A
    M F set A B C D E F G H I
    set res {}
    lappend res [M translate {1 1}]
    lappend res [M translate {1 1 0 0}]
    lappend res [M translate {1 1 0 0 1 0 1 1}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{0 0}} {{0 0 0 0}} {{0 0 0 0 1 1 1 1}}}

test dfst-2.1 {edge detector} -setup $t -body {
    M compile {
        si 0/0 s0
        si 1/0 s1
        s0 0/0 s0
        s0 1/1 s1
        s1 0/1 s0
        s1 1/0 s1
    }
    M S set si
    M F set s0
    M F set s1
    set res {}
    lappend res [M translate {1 1 0}]
    lappend res [M translate {0 0 1}]
    lappend res [M translate {1 1 0 0 1 0 1 1}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{0 0 1}} {{0 0 1}} {{0 0 1 0 1 1 1 0}}}

test dfst-2.2 {edge detector, same as above with slightly different init} -setup $t -body {
M compile {
    si 0/0 s0
    si 1/0 s1
    s0 0/0 s0
    s0 1/1 s1
    s1 0/1 s0
    s1 1/0 s1
}
M S set si
M F set s0 s1
    set res {}
    lappend res [M translate {1 1 0}]
    lappend res [M translate {0 0 1}]
    lappend res [M translate {1 1 0 0 1 0 1 1}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{0 0 1}} {{0 0 1}} {{0 0 1 0 1 1 1 0}}}

test dfst-2.3 {edge detector, same as 2.1 with slightly different init} -setup $t -body {
M compile {
    si 0/0 s0
    si 1/0 s1
    s0 0/0 s0
    s0 1/1 s1
    s1 0/1 s0
    s1 1/0 s1
}
M S set si
M F set s0 s1
    set res {}
    lappend res [M recognize {1 1 0} {0 0 1}]
    lappend res [M translate {1 1 0}]
    lappend res [M reconstruct {0 0 1 0}]
    lappend res [M generate 3]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 {{0 0 1}} {{0 0 1 1} {1 1 0 0}} {{{0 0 0} s0 {0 0 0}} {{0 0 1} s1 {0 0 1}} {{0 1 0} s0 {0 1 1}} {{0 1 1} s1 {0 1 0}} {{1 0 0} s0 {0 1 0}} {{1 0 1} s1 {0 1 1}} {{1 1 0} s0 {0 0 1}} {{1 1 1} s1 {0 0 0}}}}

test dfst-2.4 {edge detector, print} -setup $t -body {
    M compile {
        si 0/0 s0
        si 1/0 s1
        s0 0/0 s0
        s0 1/1 s1
        s1 0/1 s0
        s1 1/0 s1
    }
    M S set si
    M F set s0
    M F set s1
    M print
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -output {Input alphabet  A = {0, 1}
Output alphabet B = {0, 1}
State symbols   Q = {s0, s1, si}
Start symbol(s) S = {si}
Final symbol(s) F = {s0, s1}
Transitions
q0    inp   q1    out
si    0     s0    0
si    1     s1    0
s0    0     s0    0
s0    1     s1    1
s1    0     s0    1
s1    1     s1    0
}

cleanupTests ; return ; # ---------------------------------
