package require tcltest
namespace import ::tcltest::*

::tcltest::configure {*}$argv

::tcltest::testConstraint noskip 1

::tcltest::loadTestedCommands

proc dump machine {
    upvar 1 $machine M
    set res {}
    lappend res "A = [list [M get A]]"
    lappend res "B = [list [M get B]]"
    lappend res "Q = [list [M get Q]]"
    lappend res "S = [list [M get S]]"
    lappend res "F = [list [M get F]]"
    lappend res "transitions:"
    lappend res {*}[apply [list T {
        dict for {q moves} $T {
            dict for {a targets} $moves {
                foreach target $targets {
                    lappend res [list $q $a $target]
                }
            }
        }
        set res
    }] [M get T]]
    join $res \n
}

test fa-1.0 {} -body {
    ::automata::FSM create M
    M state add a
    M state add z
    list [M state? a] [M state? b] [M states]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 {a z}}

test startstates-1.0 {} -body {
    ::automata::FSM create M
    M start add a
    M states
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {a}

test startstates-1.1 {} -body {
    ::automata::FSM create M {Q a}
    M start add a
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {}

test startstates-1.2 {} -body {
    ::automata::FSM create M {Q a}
    M start add a
    list [M start? a] [M start? b] [M start?set {a b}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 1}

test startstates-1.3 {} -body {
    ::automata::FSM create M {Q {a b z}}
    M start add a
    M start add b
    M start add z
    M startstates
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {a b z}

test finalstates-1.0 {} -body {
    ::automata::FSM create M
    M final add a
    M states
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {a}

test finalstates-1.1 {} -body {
    ::automata::FSM create M {Q a}
    M final add a
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {}

test finalstates-1.2 {} -body {
    ::automata::FSM create M {Q a}
    M final add a
    list [M final? a] [M final? b] [M final?set {a b}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 1}

test finalstates-1.3 {} -body {
    ::automata::FSM create M {Q {a b z}}
    M final add a
    M final add b
    M final add z
    M finalstates
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {a b z}

test fsm-1.0 {} -body {
    ::automata::FSM create M
    M next 0 a --> 1 a
    M next 1 b --> 0 b
    M start add 0
    set res {}
    lappend res [M is deterministic]
    lappend res [M serialize automata::fa]
    lappend res [dump [M deserialize [lindex $res 1]]]
    set res
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {1 {automata::fa {a b} {0 {1 1 {a 1}} 1 {0 1 {b 0}}} {0 {a a} 1 {b b}}} {A = {a b}
B = {a b}
Q = {0 1}
S = 0
F = {}
transitions:
0 a {1 a}
1 b {0 b}}}

test fsm-1.1 {} -body {
    ::automata::FSM create M
    M next 0 a  --> 1 a
    M next 1 b  --> 2 b
    M next 2 {} --> 0 c
    M start add 0
    dump M
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {A = {a b}
B = {a b c}
Q = {0 1 2}
S = 0
F = {}
transitions:
0 a {1 a}
1 b {2 b}
2 {} {0 c}}

test fsm-1.2 {} -body {
    ::automata::FSM create M
    M next 0 a  --> 1 a
    M next 0 b  --> 2 d
    M next 1 b  --> 2 b
    M next 2 {} --> 0 c
    M start add 0
    M serialize
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {grammar::fa {a b c d} {0 {1 1 {a 1 b 2}} 1 {0 1 {b 2}} 2 {0 1 {{} 0}}}}

test fsm-2.0 {} -body {
    ::automata::FSM create M
    M next 0 a  --> 1 a
    M next 1 b  --> 0 b
    M start add 0
    M final add 0
    dump M
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {A = {a b}
B = {a b}
Q = {0 1}
S = 0
F = 0
transitions:
0 a {1 a}
1 b {0 b}}

test fsm-2.1 {} -body {
    ::automata::FSM create M
    M next 0 a  --> 1 a
    M next 1 b  --> 2 b
    M next 2 {} --> 0 c
    M start add 0
    M final add 0
    dump M
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {A = {a b}
B = {a b c}
Q = {0 1 2}
S = 0
F = 0
transitions:
0 a {1 a}
1 b {2 b}
2 {} {0 c}}

test dfa-1.0 {} -body {
    ::automata::FSM create M
    M next s0 0 --> s0
    M next s0 1 --> s1
    M next s1 0 --> s2
    M next s1 1 --> s0
    M next s2 0 --> s1
    M next s2 1 --> s2
    M start add s0
    M final add s0
    dump M
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {A = {0 1}
B = {}
Q = {s0 s1 s2}
S = s0
F = s0
transitions:
s0 0 s0
s0 1 s1
s1 0 s2
s1 1 s0
s2 0 s1
s2 1 s2}

test nfa-1.0 {} -body {
    ::automata::FSM create M
    M next s0 0 --> s0
    M next s0 1 --> s0
    M next s0 1 --> s1
    M next s1 0 --> s0
    M next s1 1 --> s1
    M start add s0
    M final add s1
    list [M is deterministic] [M get T]
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {0 {s0 {0 s0 1 {s0 s1}} s1 {0 s0 1 s1}}}

cleanupTests
