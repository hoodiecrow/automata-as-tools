package require tcltest
namespace import ::tcltest::*

::tcltest::configure {*}$argv

::tcltest::testConstraint noskip 1

::tcltest::loadTestedCommands

test fsm-1.0 {} -body {
    ::automata::FSM create M {
        T {
            0 {a {{1 a}}}
            1 {b {{0 b}}}
        }
        S {0}
    }
    M generate 4
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {{{a b a b} 0 {a b a b}}}

test fsm-1.1 {} -body {
    ::automata::FSM create M {
        T {
            0 {a  {{1 a}}}
            1 {b  {{2 b}}}
            2 {{} {{0 c}}}
        }
        S {0}
    }
    M generate 6
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {{{a b a b} 0 {a b c a b c}}}

test fsm-1.2 {} -body {
    ::automata::FSM create M {
        T {
            0 {a  {{1 a}} b {{2 d}}}
            1 {b  {{2 b}}}
            2 {{} {{0 c}}}
        }
        S {0}
    }
    M generate 6
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {{{a b a b} 0 {a b c a b c}} {{a b b a} 1 {a b c d c a}} {{a b b b} 2 {a b c d c d}} {{b a b a} 1 {d c a b c a}} {{b a b b} 2 {d c a b c d}} {{b b a b} 2 {d c d c a b}} {{b b b} 0 {d c d c d c}}}

test fsm-2.0 {} -body {
    ::automata::FSM create M {
        T {
            0 {a {{1 a}}}
            1 {b {{0 b}}}
        }
        S {0}
        F {0}
    }
    set res {}
    lappend res [M recognize {a b a b} {a b a b}]
    lappend res [M recognize {a b a b} {a b a c}]
    set res
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {1 0}

test fsm-2.1 {} -body {
    ::automata::FSM create M {
        T {
            0 {a  {{1 a}}}
            1 {b  {{2 b}}}
            2 {{} {{0 c}}}
        }
        S {0}
        F {0}
    }
    set res {}
    lappend res [M recognize {a b a b} {a b c a b c}]
    lappend res [M recognize {a b a b} {a b a b c}]
    set res
} -cleanup {
    log::lvSuppressLE i 1
    M destroy
} -result {1 0}

test dfa-1.0 {accept binary numbers that are multiples of 3} -body {
    ::automata::FSM create M {
        S {s0}
        F {s0}
        T {
            s0 {0 s0 1 s1}
            s1 {0 s2 1 s0}
            s2 {0 s1 1 s2}
        }
    }
    set res {}
    lappend res [M accept {1}]
    lappend res [M accept {0 1}]
    lappend res [M accept {1 1}]
    lappend res [M accept {0 0 1}]
    lappend res [M accept {1 0 1}]
    lappend res [M accept {0 1 1}]
    lappend res [M accept {1 1 1}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 0 1 0 0 1 0}

test nfa-1.0 {} -body {
    ::automata::FSM create M {
        S {s0}
        F {s1}
        T {
            s0 {0 s0 1 {s0 s1}}
            s1 {0 s0 1 s1}
        }
    }
    set res {}
    lappend res [M accept {1}]
    lappend res [M accept {0}]
    lappend res [M accept {1 1}]
    lappend res [M accept {1 0}]
    lappend res [M accept {0 1}]
    lappend res [M accept {0 0}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 1 0 1 0}

test generate-1.1 {} -body {
    ::automata::FSM create M {
        S 1
        F 1
        T {
            1 {{} {{2 {}}} a {{3 a}}}
            2 {a  {{3 b}}}
            3 {{} {{1 a}}}
        }
    }
    lsort [M generate 4]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{a 2 {b a}} {{a a} 1 {a a a a}} {{a a} 3 {a a b}} {{a a} 3 {b a a}}}

test recognize-1.0 {recognize relation {a b} -> {x y}} -body {
    ::automata::FSM create M {
        S 1
        F 1
        T {
            1 {a {{1 x}} b {{2 y}}}
            2 {{} {{1 {}}}}
        }
    }
    M recognize {a a} {x x}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1

test recognize-1.1 {recognize relation {a b} -> {x (y y)}} -body {
    ::automata::FSM create M {
        S 1
        F 1
        T {
            1 {a {{1 x}} b {{2 y}}}
            2 {{} {{1 y}}}
        }
    }
    set res {}
    lappend res [M recognize {a b a} {x y y x}]
    lappend res [M recognize {b a a b} {y y x x y}]
    lappend res [M recognize {a b a b} {x y y x y y}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 1}

test recognize-1.2 {recognize {a*(b+c+)?} relation {a b c} -> {x y z}} -body {
    ::automata::FSM create M {
        S 1
        F 1
        T {
            1 {a {{1 x}} b  {{2 y}}}
            2 {b {{2 y}} c  {{3 z}}}
            3 {c {{3 z}} {} {{1 {}}}}
        }
    }
    set res {}
    lappend res [M recognize {a b c} {x y z}]
    lappend res [M recognize {a c b} {x z x}]
    lappend res [M recognize {a b b c c a b c} {x y y z z x y z}]
    lappend res [M recognize {a b c} {x x x}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 1 0}

test dfst-1.0 {} -body {
    ::automata::FSM create M {
        S 1
        F 1
        T {
            1 {a  {{2 a}}}
            2 {{} {{1 a}}}
        }
    }
    M generate 4
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{a a} 1 {a a a a}}}


test dfst-1.1 {} -body {
    ::automata::FSM create M {
        S 1
        F 1
        T {
            1 {a  {{2 a}}}
            2 {{} {{1 a}}}
        }
    }
    M recognize {a a} {a a a a}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1


test dfst-1.2 {} -body {
    ::automata::FSM create M {
        S 1
        F 1
        T {
            1 {a  {{2 a}}}
            2 {{} {{1 a}}}
        }
    }
    M translate {a a}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{a a a a}}


test dfst-1.3 {} -body {
    ::automata::FSM create M {
        S 1
        F 1
        T {
            1 {a  {{2 a}}}
            2 {{} {{1 a}}}
        }
    }
    M reconstruct {a a a a}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{a a}}

test dfst-2.0 {The output becomes 1 and remains 1 thereafter when at least two 0's and two 1's have occurred as inputs} -body {
    ::automata::FSM create M {
        S A
        F {A B C D E F G H I}
        T {
            A {0 {{D 0}} 1 {{B 0}}}
            B {0 {{E 0}} 1 {{C 0}}}
            C {0 {{F 0}} 1 {{C 0}}}
            D {0 {{G 0}} 1 {{E 0}}}
            E {0 {{H 0}} 1 {{F 0}}}
            F {0 {{I 0}} 1 {{F 0}}}
            G {0 {{G 0}} 1 {{H 0}}}
            H {0 {{H 0}} 1 {{I 0}}}
            I {0 {{I 1}} 1 {{I 1}}}
        }
    }
    set res {}
    lappend res [M translate {1 1}]
    lappend res [M translate {1 1 0 0}]
    lappend res [M translate {1 1 0 0 1 0 1 1}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{0 0}} {{0 0 0 0}} {{0 0 0 0 1 1 1 1}}}

test dfst-2.1 {edge detector} -body {
    ::automata::FSM create M {
        S si
        F {s0 s1}
        T {
            si {0 {{s0 0}} 1 {{s1 0}}}
            s0 {0 {{s0 0}} 1 {{s1 1}}}
            s1 {0 {{s0 1}} 1 {{s1 0}}}
        }
    }
    set res {}
    lappend res [M translate {1 1 0}]
    lappend res [M translate {0 0 1}]
    lappend res [M translate {1 1 0 0 1 0 1 1}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{0 0 1}} {{0 0 1}} {{0 0 1 0 1 1 1 0}}}

test dfst-2.2 {moore machine} -constraints SKIP -body {
    ::automata::FSM create M {
        S A
        F {A B C D E F G H I}
        T {
            {{A 0} {0 D 1 B}}
            {{B 0} {0 E 1 C}}
            {{C 0} {0 F 1 C}}
            {{D 0} {0 G 1 E}}
            {{E 0} {0 H 1 F}}
            {{F 0} {0 I 1 F}}
            {{G 0} {0 G 1 H}}
            {{H 0} {0 H 1 I}}
            {{I 1} {0 I 1 I}}
        }
    }
    set res {}
    log::lvSuppressLE i 0
    lappend res [M translate {1 1}]
    log::lvSuppressLE i 1
    lappend res [M translate {1 1 0 0}]
    lappend res [M translate {1 1 0 0 1 0 1 1}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{0 0}} {{0 0 0 0}} {{0 0 0 0 1 1 1 1}}}


if {[package vcompare [package present automata] 2.3] > 0} { 
    cleanupTests ; return 
} 
 
test nfa-1.1 {find even number of ones/zeros} -body {
    FSM create M {
        S {s0}
        F {s1 s3}
        T {
            s0 {{} {s1 s3}}
            s1 {0 s2 1 s1}
            s2 {0 s1 1 s2}
            s3 {0 s3 1 s4}
            s4 {0 s4 1 s3}
        }
    }
    set res {}
    lappend res [M accept {1 1}]
    lappend res [M accept {1 0}]
    lappend res [M accept {0 1}]
    lappend res [M accept {0 0}]
    lappend res [M accept {1 0 0 1 1 1}]
    lappend res [M accept {1 0 0 1 1 0}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 0 1 1 0}


# http://cs.union.edu/~striegnk/courses/nlp-with-prolog/html/node13.html

test dfa-1.0 {accept binary numbers that are multiples of 3} -body {
    FSM create M {
        s s0
        A s0
    } {
        s0 0 s0
        s0 0 s0
        s0 1 s1
        s1 0 s2
        s1 1 s0
        s2 0 s1
        s2 1 s2
    }
    set res {}
    lappend res [M accept {1}]
    lappend res [M accept {0 1}]
    lappend res [M accept {1 1}]
    lappend res [M accept {0 0 1}]
    lappend res [M accept {1 0 1}]
    lappend res [M accept {0 1 1}]
    lappend res [M accept {1 1 1}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 0 1 0 0 1 0}

test nfa-1.0 {} -body {
    FSM create M {
        s s0
        A s1
    } {
        s0 0 s0
        s0 1 {s0 s1}
        s1 0 s0
        s1 1 s1
    }
    set res {}
    lappend res [M accept {1}]
    lappend res [M accept {0}]
    lappend res [M accept {1 1}]
    lappend res [M accept {1 0}]
    lappend res [M accept {0 1}]
    lappend res [M accept {0 0}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 1 0 1 0}

test nfa-1.1 {find even number of ones/zeros} -body {
    FSM create M {
        s s0
        A {s1 s3}
    } {
        s0 ε {s1 s3}
        s1 0 s2
        s1 1 s1
        s2 0 s1
        s2 1 s2
        s3 0 s3
        s3 1 s4
        s4 0 s4
        s4 1 s3
    }
    set res {}
    lappend res [M accept {1 1}]
    lappend res [M accept {1 0}]
    lappend res [M accept {0 1}]
    lappend res [M accept {0 0}]
    lappend res [M accept {1 0 0 1 1 1}]
    lappend res [M accept {1 0 0 1 1 0}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 0 1 1 0}

test dfst-1.0 {} -body {
    FSM create M {s 1 A 1} {1 "a a" 2 2 "ε a" 1}
    M generate 4
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{a a} {a a a a}}}


test dfst-1.1 {} -body {
    FSM create M {s 1 A 1} {1 "a a" 2 2 "ε a" 1}
    M recognize {a a} {a a a a}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1


test dfst-1.2 {} -body {
    FSM create M {s 1 A 1} {1 "a a" 2 2 "ε a" 1}
    M translate {a a}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{a a a a}}


test dfst-1.3 {} -body {
    FSM create M {s 1 A 1} {1 "a a" 2 2 "ε a" 1}
    M reconstruct {a a a a}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{a a}}

test generate-1.0 {} -body {
    FSM create M {s 1 A 1} {1 "a a" 2 2 "ε a" 1}
    M generate 4
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{a a} {a a a a}}}


test generate-1.1 {} -body {
    FSM create M {s 1 A 1} {
        1 "ε ε" 2
        1 "a a" 3
        2 "a b" 3
        3 "ε a" 1
    }
    lsort [M generate 4]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{a {b a}} {{a a} {a a a a}} {{a a} {a a b}} {{a a} {b a a}}}


test recognize-1.0 {recognize relation {a b} -> {x y}} -body {
    FSM create M {s 1 A 1} {
        1 "a x" 1
        1 "b y" 2
        2 "ε ε" 1
    }
    M recognize {a a} {x x}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1

test recognize-1.1 {recognize relation {a b} -> {x y}} -body {
    FSM create M {s 1 A 1} {
        1 "a x" 1
        1 "b y" 2
        2 "ε ε" 1
    }
    M recognize {a b a} {x y x}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1

test recognize-1.2 {recognize {a*(b+c+)?} relation {a b c} -> {x y z}} -body {
    FSM create M {s 1 A 1} {
        1 "a x" 1
        1 "b y" 2
        2 "b y" 2
        2 "c z" 3
        3 "c z" 3
        3 "ε ε" 1
    }
    set res {}
    lappend res [M recognize {a b c} {x y z}]
    lappend res [M recognize {a c b} {x z x}]
    lappend res [M recognize {a b b c c a b c} {x y y z z x y z}]
    lappend res [M recognize {a b c} {x x x}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 1 0}

test dfst-2.0 {The output becomes 1 and remains 1 thereafter when at least two 0's and two 1's have occurred as inputs} -body {
    FSM create M {
        I {0 1}
        O {0 1}
        S {A B C D E F G H I}
        s A
        A {A B C D E F G H I}
    } {
        A "0 0" D
        A "1 0" B
        B "0 0" E
        B "1 0" C
        C "0 0" F
        C "1 0" C
        D "0 0" G
        D "1 0" E
        E "0 0" H
        E "1 0" F
        F "0 0" I
        F "1 0" F
        G "0 0" G
        G "1 0" H
        H "0 0" H
        H "1 0" I
        I "0 1" I
        I "1 1" I
    }
    set res {}
    lappend res [M translate {1 1}]
    lappend res [M translate {1 1 0 0}]
    lappend res [M translate {1 1 0 0 1 0 1 1}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{0 0}} {{0 0 0 0}} {{0 0 0 0 1 1 1 1}}}

test dfst-2.1 {edge detector} -body {
    FSM create M {
        I {0 1}
        O {0 1}
        S {si s0 s1}
        s si
        A {s0 s1}
    } {
        si "0 0" s0
        si "1 0" s1
        s0 "0 0" s0
        s0 "1 1" s1
        s1 "0 1" s0
        s1 "1 0" s1
    }
    set res {}
    lappend res [M translate {1 1 0}]
    lappend res [M translate {0 0 1}]
    lappend res [M translate {1 1 0 0 1 0 1 1}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{0 0 1}} {{0 0 1}} {{0 0 1 0 1 1 1 0}}}

test dfst-2.2 {moore machine} -body {
    FSM create M {
        I {0 1}
        O {0 1}
        S {A B C D E F G H I}
        s A
        A {A B C D E F G H I}
    } {
        "A 0" 0 D
        "A 0" 1 B
        "B 0" 0 E
        "B 0" 1 C
        "C 0" 0 F
        "C 0" 1 C
        "D 0" 0 G
        "D 0" 1 E
        "E 0" 0 H
        "E 0" 1 F
        "F 0" 0 I
        "F 0" 1 F
        "G 0" 0 G
        "G 0" 1 H
        "H 0" 0 H
        "H 0" 1 I
        "I 1" 0 I
        "I 1" 1 I
    }
    set res {}
    lappend res [M translate {1 1}]
    lappend res [M translate {1 1 0 0}]
    lappend res [M translate {1 1 0 0 1 0 1 1}]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{0 0}} {{0 0 0 0}} {{0 0 0 0 1 1 1 1}}}

    # this isn't non-det
    set Tlex {
        0 "d NOUN" 1
        0 "f NOUN" 2
        0 "g NOUN" 3
        0 "m NOUN" 4
        1 "o sg" 14
        2 "i sg" 12
        3 "o sg" 10
        3 "e pl" 11
        4 "o sg" 6
        4 "i pl" 5
        5 "c ε" 8
        6 "u ε" 7
        7 "s ε" 8
        8 "e ε" 9
        10 "o ε" 7
        11 "e ε" 7
        12 "s ε" 13
        13 "h ε" 9
        14 "g ε" 9
        15 "g ε" 16
        16 "s ε" 9
    }

test nfst-1.0 {} -body {
    FSM create M {s 0 A {9}} $Tlex
    M translate [split dog {}]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{NOUN sg}}

test nfst-1.1 {} -body {
    FSM create M {s 0 A {9}} $Tlex
    set res {}
    lappend res [lsort [M translate [split fish {}]]]
    lappend res [lsort [M translate [split geese {}]]]
    lappend res [lsort [M translate [split mouse {}]]]
    lappend res [lsort [M translate [split mice {}]]]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{{NOUN sg}} {{NOUN pl}} {{NOUN sg}} {{NOUN pl}}}

# http://web.cs.ucdavis.edu/~rogaway/classes/120/spring13/eric-transducers.pdf


cleanupTests ; return ; # ---------------------------------




test tm-1.0 {3 state, 2 symbol busy beaver} -body {
    DTM create M {
        I {0 1}
        S {A B C HALT}
        T {0 1}
        s A
        H {HALT}
        b 0
        t {
            {A 0} B
            {A 1} C
            {B 0} A
            {B 1} B
            {C 0} B
            {C 1} HALT
        }
        o {
            {A 0} {1 R}
            {A 1} {1 L}
            {B 0} {1 L}
            {B 1} {1 R}
            {C 0} {1 L}
            {C 1} {1 R}
        }
    }
    M run
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 0 0 0 0 1 1 1 1 1 1 0 0 0}

test tm-1.1 {4 state, 2 symbol busy beaver} -body {
    DTM create M {
        I {0 1}
        S {A B C D HALT}
        T {0 1}
        s A
        H {HALT}
        b 0
        t {
            {A 0} B
            {A 1} B
            {B 0} A
            {B 1} C
            {C 0} HALT
            {C 1} D
            {D 0} D
            {D 1} A
        }
        o {
            {A 0} {1 R}
            {A 1} {1 L}
            {B 0} {1 L}
            {B 1} {0 L}
            {C 0} {1 R}
            {C 1} {1 L}
            {D 0} {1 R}
            {D 1} {0 R}
        }
    }
    M run
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0}

test tm-1.2 {4 state, 2 symbol busy beaver} -body {
    DTM create M {
        I {0 1}
        S {A B C D HALT}
        T {0 1}
        s A
        H {HALT}
        b 0
        t {
            {A 0} B
            {A 1} B
            {B 0} A
            {B 1} C
            {C 0} HALT
            {C 1} D
            {D 0} D
            {D 1} A
        }
        o {
            {A 0} {1 R}
            {A 1} {1 L}
            {B 0} {1 L}
            {B 1} {0 L}
            {C 0} {1 R}
            {C 1} {1 L}
            {D 0} {1 R}
            {D 1} {0 R}
        }
    }
    tuple2json [M tuple]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{
    "I" : ["0","1"],
    "S" : ["A","B","C","D","HALT"],
    "T" : ["0","1"],
    "s" : "A",
    "H" : ["HALT"],
    "b" : "0",
    "t" : {
        "A 0" : ["B"],
        "A 1" : ["B"],
        "B 0" : ["A"],
        "B 1" : ["C"],
        "C 0" : ["HALT"],
        "C 1" : ["D"],
        "D 0" : ["D"],
        "D 1" : ["A"]
    },
    "o" : {
        "A 0" : ["1","R"],
        "A 1" : ["1","L"],
        "B 0" : ["1","L"],
        "B 1" : ["0","L"],
        "C 0" : ["1","R"],
        "C 1" : ["1","L"],
        "D 0" : ["1","R"],
        "D 1" : ["0","R"]
    }
}}

# 2-state, 2-symbol busy beaver as a Post-Turing machine
#
test ptbb-1.0 {} -body {
    PTM create M {
        C {
            begin:  J1:a
                    P R J:b
            a:      P L J:b
            b:      J1:c
                    P L J:begin
            c:      P H
        }
        b " "
        m |
        H {H}
    }
    join [M run] {}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {||||}

# 2-state, 2-symbol busy beaver as a Post-Turing machine, with cleanup
#
test ptbb-1.1 {} -body {
    PTM create M {
        C {
            begin:  J1:a
                    P R J:b
            a:      P L J:b
            b:      J1:c
                    P L J:begin
            c:      L
            d:      J0:done
                    E R J1:d
            done:   H
        }
        b { }
        m |
        H {H}
    }
    join [M run] {}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {     }

# Post-Turing machine to multiply two values
#
test ptbb-1.2 {} -body {
    PTM create M {
        C {
            R J1:*-1 R J1:*-1 R P
            L
   a_loop:  L J1:*-1 L J1:*-1 R
            E
            R J0:done
            R J1:*-1 R
   b_loop:  R
            J0:a_loop
            E
            R J1:*-1 R J1:*-1
            P
            L J1:*-1 L J1:*-1 P
            J1:b_loop
            R
            J0:a_loop
            E
   done:    H
        }
        b { }
        m |
        H {H}
    } [split { |||| |||||  } {}] 0
    join [M run] {}
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {      ||||| |||||||||||||}

# 2-state, 2-symbol busy beaver as a Post-Turing machine
#
test ptbb-1.3 {} -body {
    PTM create M {
        C {
            begin:  J1:a
                    P R J:b
            a:      P L J:b
            b:      J1:c
                    P L J:begin
            c:      P H
        }
        b { }
        m |
        H {H}
    }
    tuple2json [M tuple]
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {{
    "C" : ["J1","6","P","R","J","10","P","L","J","10","J1","16","P","L","J","0","P","H"],
    "b" : " ",
    "m" : "|",
    "H" : ["H"]
}}





cleanupTests ; return ; # ---------------------------------



namespace import ::FSM::*

test dfa-1.0 {} -body {
    Machine M {
        input i {}
        State s0 {
            transition 0 s0
            transition 1 s1
        }
        State s1 {
            transition 0 s2
            transition 1 s0
        }
        State s2 {
            transition 0 s1
            transition 1 s2
        }
        start s0
        accept {in {s0}}
    }
    M run
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result 1

test dfa-1.1 {} -body {
    Machine M {
        input i {}
        State s0 {
            transition 0 s0
            transition 1 s1
        }
        State s1 {
            transition 0 s2
            transition 1 s0
        }
        State s2 {
            transition 0 s1
            transition 1 s2
        }
        start s0
        accept {in {s0}}
    }
    set res {}
    M set input i {1}
    lappend res [M run]
    M set input i {0 1}
    lappend res [M run]
    M set input i {1 1}
    lappend res [M run]
    M set input i {0 0 1}
    lappend res [M run]
    M set input i {1 0 1}
    lappend res [M run]
    M set input i {0 1 1}
    lappend res [M run]
    M set input i {1 1 1}
    lappend res [M run]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {0 0 1 0 0 1 0}

test nfa-1.0 {} -body {
    Machine M {
        input i {}
        State s0 {
            transition 0 s0
            transition 1 s0
            transition 1 s1
        }
        State s1 {
            transition 0 s0
            transition 1 s1
        }
        start s0
        accept {in {s1}}
    }
    set res {}
    M set input i {1}
    lappend res [M run]
    M set input i {0}
    lappend res [M run]
    M set input i {1 1}
    lappend res [M run]
    M set input i {1 0}
    lappend res [M run]
    M set input i {0 1}
    lappend res [M run]
    M set input i {0 0}
    lappend res [M run]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 1 0 1 0}

test nfa-1.1 {find even number of ones/zeros} -body {
    Machine M {
        State s0 {
            transition ε s1
            transition ε s3
        }
        State s1 {
            transition 0 s2
            transition 1 s1
        }
        State s2 {
            transition 0 s1
            transition 1 s2
        }
        State s3 {
            transition 0 s3
            transition 1 s4
        }
        State s4 {
            transition 0 s4
            transition 1 s3
        }
        start s0
        accept {in {s1 s3}}
    }
    set res {}
    M set input i {1 1}
    lappend res [M run]
    M set input i {1 0}
    lappend res [M run]
    M set input i {0 1}
    lappend res [M run]
    M set input i {0 0}
    lappend res [M run]
    M set input i {1 0 0 1 1 1}
    lappend res [M run]
    M set input i {1 0 0 1 1 0}
    lappend res [M run]
    set res
} -cleanup {
    M destroy
    log::lvSuppressLE i 1
} -result {1 0 0 1 1 0}




cleanupTests ; return ; # ---------------------------------
